# 1.1.3. Iteración 3: Modelado del Sistema y Algoritmo (CRISP-DM) + Sprint 3 (SCRUM)

## Selección de algoritmos candidatos

Tras la revisión bibliográfica y el análisis de los tipos de datos recolectados (valores clínicos cuantitativos, variables categóricas como sexo y actividad, y atributos nutricionales de los ingredientes), se identificaron como algoritmos candidatos:

Regresión logística: Como línea base interpretable y de bajo costo computacional. Permite explicar decisiones mediante coeficientes, pero tiene limitaciones para capturar interacciones no lineales entre variables clínicas y nutricionales.

Random Forest: Modelo de ensamblado robusto, capaz de manejar no linealidades y variables heterogéneas, con interpretabilidad relativa mediante importancia de variables. Utiliza múltiples árboles de decisión entrenados en subconjuntos aleatorios de datos y características, promediando sus predicciones para reducir sobreajuste.

XGBoost (Extreme Gradient Boosting): Algoritmo de boosting altamente eficiente y preciso, particularmente recomendado en contextos tabulares con datos clínicos y de salud. Implementa optimización de segundo orden (aproximación de Newton) y regularización L1 y L2 para prevenir sobreajuste.

## Tabla comparativa de algoritmos de ML

Criterio Regresión logística: Precisión esperada media, buena en problemas lineales. Interpretabilidad muy alta (coeficientes claros). Manejo de datos heterogéneos limitado, requiere codificación manual. Escalabilidad excelente, muy rápido. Rendimiento computacional muy bajo costo. Aplicabilidad clínica buena como baseline explicable. Compatibilidad con ecosistema Python/Postgres muy alta (sklearn).

Criterio KNN (k-Nearest Neighbors): Precisión esperada media, sensible al número de vecinos y ruido. Interpretabilidad baja, difícil interpretar vecinos. Manejo de datos heterogéneos limitado, necesita escalado. Escalabilidad mala en grandes volúmenes (búsqueda costosa). Rendimiento computacional alto costo en datasets medianos/grandes. Aplicabilidad clínica poca adopción clínica por opacidad. Compatibilidad con ecosistema Python/Postgres alta (sklearn).

Criterio SVM (Support Vector Machine): Precisión esperada alta en datasets pequeños/limpios. Interpretabilidad media-baja (depende de kernel). Manejo de datos heterogéneos limitado, necesita normalización rigurosa. Escalabilidad costosa en alta dimensionalidad. Rendimiento computacional alto, sensible a hiperparámetros. Aplicabilidad clínica limitada en práctica clínica por complejidad. Compatibilidad con ecosistema Python/Postgres alta (sklearn).

Criterio Árbol de decisión: Precisión esperada media, tiende a sobreajustar. Interpretabilidad alta, reglas claras. Manejo de datos heterogéneos bueno, acepta variables mixtas. Escalabilidad buena, pero se degrada con complejidad. Rendimiento computacional bajo, rápido. Aplicabilidad clínica útil para reglas clínicas simples. Compatibilidad con ecosistema Python/Postgres muy alta (sklearn).

Criterio Random Forest: Precisión esperada alta, robusto con ruido y complejidad. Interpretabilidad media (feature importance). Manejo de datos heterogéneos muy bueno, maneja datos mixtos. Escalabilidad buena, paralelizable. Rendimiento computacional moderado. Aplicabilidad clínica muy buena, balancea precisión e interpretabilidad. Compatibilidad con ecosistema Python/Postgres muy alta (sklearn).

Criterio XGBoost: Precisión esperada muy alta, líder en tabulares. Interpretabilidad baja-media (requiere SHAP/LIME). Manejo de datos heterogéneos excelente, captura interacciones complejas. Escalabilidad excelente, optimizado para grandes volúmenes. Rendimiento computacional alto, requiere mayor tiempo de entrenamiento. Aplicabilidad clínica excelente, altamente competitivo en salud digital. Compatibilidad con ecosistema Python/Postgres muy alta (xgboost, sklearn API).

La elección final se inclinó hacia el uso de XGBoost como algoritmo principal para los tres modelos ML, con Random Forest como complemento en el Modelo 3 mediante ensemble. Para el Modelo 1 (Predicción de Respuesta Glucémica), se seleccionó XGBoost Regressor por su excelente rendimiento en problemas de regresión con múltiples targets, capacidad de capturar interacciones complejas entre características del paciente y del alimento, y eficiencia computacional para predicciones en tiempo real. Para el Modelo 2 (Selección Personalizada de Alimentos), se seleccionó XGBoost Classifier por su capacidad de manejar desbalance de clases mediante scale_pos_weight, alta precisión en clasificación binaria, y capacidad de proporcionar probabilidades calibradas que se utilizan directamente como scores de idoneidad. Para el Modelo 3 (Optimización de Combinaciones), se implementó un ensemble que combina XGBoost Regressor y Random Forest Regressor, promediando sus predicciones. Random Forest se incluye por su robustez frente a ruido y complementariedad con XGBoost (diferentes sesgos y varianzas), mientras que XGBoost aporta alta precisión. El ensemble generalmente muestra mejor rendimiento que los modelos individuales, validando la estrategia de combinación. Esta arquitectura de tres modelos especializados permite optimizar cada tarea específica dentro del flujo de recomendación, mejorando tanto la seguridad (Modelo 1) como la personalización (Modelo 2) y calidad nutricional (Modelo 3) de las recomendaciones.

## 1.1.3.1. Propósito y alcance del sprint

En esta iteración se consolidó el motor de recomendación nutricional como un sistema híbrido: un motor experto basado en conocimiento clínico (reglas y fórmulas validadas para DM2) y un componente de aprendizaje automático entrenado con dataset tabular de salud (perfil clínico-antropométrico) para ajustar metas y priorizar combinaciones de alimentos.

El alcance incluyó: diseño de clases y datatypes, cálculo de metas personalizadas, filtrado seguro de ingredientes, generación de planes diarios y semanales con variedad real y acoplamiento del modelo ML para ajustes adaptativos y priorización por riesgo metabólico.

## 1.1.3.2. Arquitectura lógica del módulo (versión híbrida)

Motor experto (reglas): Cálculo de TMB (Mifflin-St Jeor) más factor de actividad más factor de diabetes (ajustes por HbA1c, glucosa en ayunas, IMC y PA). Metas de macronutrientes (rangos DM2), fibra objetivo mayor o igual a 25 gramos, sodio 1500-2300 mg según PA. Distribución de CHO por tiempo de comida (desayuno, media mañana, almuerzo, media tarde, cena). Filtros seguros: IG menor o igual a umbral, alergias, exclusiones por preferencia y por grupo alimentario. Generación con variedad: funciones _sugerir_desayuno_variado, _sugerir_almuerzo_variado, _sugerir_cena_variada por tiempo de comida y rotación semanal.

Componente ML (aprendizaje automático) integrado: El sistema implementa tres modelos ML especializados que trabajan en conjunto para mejorar la personalización y precisión de las recomendaciones.

Modelo 1: Predicción de Respuesta Glucémica. Algoritmo: XGBoost Regressor con múltiples targets. Entrenado con: datos de CGMacros que incluyen perfiles de pacientes, características de alimentos y respuestas glucémicas postprandiales medidas mediante monitoreo continuo de glucosa (CGM). Targets: glucose_increment (incremento de glucosa en mg/dL), glucose_peak (pico de glucosa en mg/dL), time_to_peak (tiempo hasta el pico en minutos). Features de entrada: perfil del paciente (edad, sexo, IMC, peso, talla, HbA1c, glucosa en ayunas, triglicéridos), características del alimento (kcal, CHO, PRO, FAT, fibra), features derivadas (CHO por 100 kcal, PRO por 100 kcal, FAT por 100 kcal, fibra por 100 kcal), contexto (hora del día, tipo de comida, tiempo desde última comida, glucosa baseline). Utilidad: Permite predecir cómo responderá la glucosa de un paciente específico a un alimento específico. Si glucose_peak predicho mayor a 180 mg/dL, el alimento se excluye automáticamente antes de incluirlo en el plan. Integración: Se utiliza durante la selección de alimentos mediante función predecir_respuesta_glucemica que se llama para cada alimento candidato antes de la selección final.

Modelo 2: Selección Personalizada de Alimentos. Algoritmo: XGBoost Classifier. Entrenado con: combinación de datos de MyFitnessPal (frecuencia de consumo de alimentos) y CGMacros (respuestas glucémicas), procesados mediante script preparar_datos_modelo2_seleccion_alimentos.py. Target: score_idoneidad (0-1) calculado basándose en respuesta glucémica (50% del score), frecuencia de consumo (30% del score) y preferencias (20% del score). Features de entrada: perfil del paciente (edad, sexo, IMC, HbA1c, glucosa en ayunas), características del alimento (kcal, CHO, PRO, FAT, sodio, azúcar), features derivadas (CHO por 100 kcal, PRO por 100 kcal, FAT por 100 kcal), frecuencia de consumo del alimento. Utilidad: Calcula score de idoneidad (0-1) de un alimento específico para un paciente específico. Los alimentos se ordenan por score descendente antes de la selección, priorizando aquellos con mayor idoneidad. Integración: Se utiliza durante la selección de alimentos mediante función calcular_score_idoneidad_alimento que se llama para rankear alimentos candidatos.

Modelo 3: Optimización de Combinaciones. Algoritmo: Ensemble (XGBoost Regressor más Random Forest Regressor) que promedia predicciones de ambos modelos. Entrenado con: datos de CGMacros procesados mediante script preparar_datos_modelo3_combinaciones.py que agrupa comidas cercanas en tiempo para representar combinaciones completas. Target: score_calidad (0-1) calculado basándose en incremento de glucosa (70% del score) y variabilidad de glucosa (30% del score). Features de entrada: perfil del paciente (edad, sexo, IMC, HbA1c, glucosa en ayunas), totales de la combinación (kcal total, CHO total, PRO total, FAT total, fibra total), features derivadas (porcentaje CHO, porcentaje PRO, porcentaje FAT), diversidad (número de tipos de comida diferentes en la combinación), contexto (hora de la primera comida, duración de la combinación). Utilidad: Evalúa calidad de combinaciones de alimentos (score 0-1) para un paciente específico. Se utiliza durante la optimización para validar que combinaciones sugeridas tengan calidad adecuada (score mayor a 0.6). Integración: Se utiliza durante la optimización del plan mediante función evaluar_combinacion_alimentos que se llama para validar combinaciones sugeridas por el optimizador.

Integración on-line: Antes de generar el plan, el motor carga los tres modelos ML bajo demanda mediante funciones _cargar_modelo_respuesta_glucemica, _cargar_modelo_seleccion_alimentos y _cargar_modelo_optimizacion_combinaciones. Durante la generación del plan, el Modelo 1 se utiliza para excluir alimentos con pico glucémico excesivo, el Modelo 2 se utiliza para rankear alimentos por idoneidad, y el Modelo 3 se utiliza durante la optimización para validar calidad de combinaciones. El plan base se ajusta según predicciones de los modelos ML, manteniendo siempre seguridad clínica como prioridad.

Capa de orquestación y API: Entradas: paciente_id, configuración de plan (fechas, kcal objetivo opcional, porcentaje macros opcionales, IG máximo, patrón de comidas, exclusiones). Salidas: perfil resumido, metas finales (tras ajuste ML), plan semanal con variedad, validaciones, lista de compras y explicaciones (mensajes de trazabilidad y variables más influyentes).

## Endpoints del módulo de recomendación

Método POST, Endpoint /api/recomendacion/generar: Request JSON con paciente_id, configuracion (dias_plan, kcal_obj, macros, ig_max, exclusiones), ingredientes (incluir, excluir, grupos_excluidos). Response 200 OK más plan_completo, metas_nutricionales, resumen_semanal, recomendaciones_especiales. Roles nutricionista, admin.

Método GET, Endpoint /api/recomendacion/<int:paciente_id>: Query params dias=7, kcal=2000, cho_pct=50, pro_pct=18, fat_pct=32, ig_max=70, grupos_excluir=GRUPO1_CEREALES,GRUPO6_AZUCARES. Response 200 OK más plan_completo, metas_nutricionales, perfil, validaciones. Roles nutricionista, admin, paciente (solo sus planes).

Método POST, Endpoint /api/planes: JSON con paciente_id, estado, plan, configuracion, ingredientes. Response 200 OK más id: plan_id, detalle_url. Roles nutricionista, admin.

Método GET, Endpoint /planes/<plan_id>: Response 200 OK más Vista HTML del plan detallado. Roles nutricionista, admin, paciente (solo sus planes).

Método GET, Endpoint /api/ingredientes/activos: Query params q=arroz, grupo=GRUPO1_CEREALES. Response 200 OK más ok: true, rows con id, nombre, grupo, kcal, cho, pro, fat, fibra, ig, sodio, costo, unidad_base, porcion_base, tags_full, activo. Roles nutricionista, admin.

Método GET, Endpoint /api/paciente/<int:pid>/medicamentos: Response 200 OK más ok: true, data con id, nombre, fecha_registro. Roles nutricionista, admin.

Método POST, Endpoint /api/paciente/<int:pid>/medicamentos: JSON con items (nombre: "Metformina", nombre: "Insulina"). Response 200 OK más ok: true. Roles nutricionista, admin.

Método GET, Endpoint /api/paciente/<int:pid>/alergias: Response 200 OK más ok: true, data con id, ingrediente_id, ingrediente_nombre, descripcion. Roles nutricionista, admin.

Método POST, Endpoint /api/paciente/<int:pid>/alergias: JSON con items (ingrediente_id: 1, descripcion: "Alergia leve"). Response 200 OK más ok: true. Roles nutricionista, admin.

## 1.1.3.3. Estructuras de datos y flujo principal

Dataclasses implementadas: PerfilPaciente contiene edad, sexo, peso, talla, IMC, actividad, HbA1c, glucosa, LDL, PA, alergias, medicación, preferencias (incluir/excluir). MetaNutricional contiene kcal por día; gramos y porcentaje de CHO/PRO/FAT; fibra en gramos; sodio en mg; CHO por comida.

Flujo simple implementado mediante los siguientes pasos numerados:

1. Obtención del perfil del paciente: Se ejecuta obtener_perfil_paciente(paciente_id) que retorna último registro clínico y última antropometría del paciente desde la base de datos. Se deriva IMC mediante cálculo de peso dividido por talla al cuadrado. Se recuperan listas clínicas (alergias y medicación) y preferencias alimentarias del paciente desde tablas relacionadas.

2. Cálculo de metas nutricionales base: Se ejecuta calcular_metas_nutricionales(perfil, configuracion) que calcula metas base mediante reglas clínicas (TMB, factor de actividad, factor de diabetes). Se aplica ajuste ML mediante predecir_control_glucemico_ml que utiliza modelo de control glucémico (legacy) para ajustar probabilidad de mal control. La probabilidad se utiliza para ajustar umbral de IG y distribución calórica por comidas.

3. Aplicación de ajustes seguros: Se aplican ajustes con cotas (límites clínicos) para generar metas_finales. Los ajustes se limitan a rangos seguros: calorías entre más menos 10% de la meta base, macros dentro de rangos DM2 (CHO 45-60%, PRO 15-20%, FAT 25-35%), IG máximo ajustado según probabilidad de mal control.

4. Obtención de ingredientes recomendados: Se ejecuta obtener_ingredientes_recomendados(perfil, metas_finales, filtros) que aplica filtros de seguridad: IG menor o igual a umbral configurado, exclusión de alérgenos del paciente, exclusión de grupos alimentarios según preferencias, exclusión de ingredientes específicos según preferencias. Se utiliza Modelo 2 (calcular_score_idoneidad_alimento) para calcular score de idoneidad (0-1) de cada alimento candidato. Los alimentos se ordenan por score descendente, priorizando aquellos con mayor idoneidad para el perfil del paciente.

5. Generación del plan semanal: Se ejecuta generar_plan_semanal que genera variedad por día y tiempo de comida mediante funciones _sugerir_desayuno_variado, _sugerir_almuerzo_variado, _sugerir_cena_variada, _sugerir_merienda_variada. Durante la generación, se utiliza Modelo 1 (predecir_respuesta_glucemica) para cada alimento candidato antes de incluirlo en el plan. Si glucose_peak predicho mayor a 180 mg/dL, el alimento se excluye automáticamente. Se aplica algoritmo de rotación y filtrado por repetición para garantizar variedad semanal.

6. Optimización del plan: Se ejecuta OptimizadorPlan que ajusta cantidades y combinaciones de alimentos para cumplir objetivos nutricionales con mayor precisión. Durante la optimización, se utiliza Modelo 3 (evaluar_combinacion_alimentos) para validar calidad de combinaciones sugeridas. Si score de calidad menor a 0.6, se busca alternativa. Se optimiza balance de macronutrientes y distribución calórica por comidas.

7. Validaciones finales: Se ejecutan validaciones automáticas: calorías dentro de más menos 10% de meta diaria, porcentaje de macros dentro de rangos clínicos (CHO 45-60%, PRO 15-20%, FAT 25-35%), IG máximo respetado en todos los alimentos, ausencia de grupos o alimentos excluidos, ausencia de alérgenos en el plan generado.

8. Conversión y persistencia: Se convierte el plan a formato UI (estructura JSON con días, comidas, alimentos y valores nutricionales). Se genera lista de compras agregando cantidades de ingredientes por día y semana. Se generan explicaciones y recomendaciones especiales basadas en decisiones del sistema (ajustes aplicados, alimentos excluidos y razones, variables más influyentes). Se persiste opcionalmente en base de datos mediante endpoint POST /api/planes con estado "borrador" o "publicado".

## 1.1.3.4. Funcionamiento del motor de recomendación

### 1.1.3.4.1. Cálculo de metabolismo basal (calcular_metabolismo_basal)

El metabolismo basal (TMB) representa la cantidad mínima de energía que el cuerpo humano necesita para mantener sus funciones vitales básicas en condiciones de reposo absoluto, es decir, sin realizar actividad física, después de 12 horas de ayuno y en un ambiente térmicamente neutro. Esta medida es fundamental en el contexto de la diabetes tipo 2, ya que constituye la base sobre la cual se calculan las necesidades calóricas totales del paciente, determinando así la cantidad de calorías que debe consumir diariamente para mantener, perder o ganar peso de manera saludable.

Para el cálculo del metabolismo basal, se implementó la ecuación de Mifflin-St Jeor como algoritmo de referencia, seleccionada por su amplia adopción en sistemas de salud digital y su validación mediante estudios comparativos que demuestran mayor precisión (más menos 10%). Esta ecuación fue elegida específicamente por su compatibilidad con datos antropométricos estándar y su implementación computacional eficiente.

La ecuación utiliza tres variables antropométricas básicas y aplica diferentes constantes según el sexo del paciente. Para hombres: TMB = (10 multiplicado por peso) más (6.25 multiplicado por talla) menos (5 multiplicado por edad) más 5. Para mujeres: TMB = (10 multiplicado por peso) más (6.25 multiplicado por talla) menos (5 multiplicado por edad) menos 161.

Definición de la función: La función calcular_metabolismo_basal recibe un objeto PerfilPaciente y retorna un float. Implementa una estructura condicional que verifica el sexo del paciente mediante perfil.sexo == 'M'. Si es masculino, aplica la fórmula con constante positiva 5; si es femenino, aplica la fórmula con constante negativa 161. La talla se convierte de metros a centímetros multiplicando por 100 antes de aplicar la fórmula.

Análisis de los componentes de la fórmula: El componente peso (10 multiplicado por peso_kg) representa la contribución del tejido magro (músculo, órganos, huesos) al metabolismo basal. El coeficiente 10 kcal por kg refleja el costo energético de mantener la masa corporal activa. En pacientes con diabetes tipo 2, este componente es crucial porque la composición corporal (proporción de masa magra versus grasa) influye directamente en la sensibilidad a la insulina.

El componente talla (6.25 multiplicado por talla_cm) refleja la influencia de la altura en el TMB principalmente a través del área superficial corporal, que determina la pérdida de calor y, por tanto, la necesidad de generar calor para mantener la temperatura corporal. El coeficiente 6.25 kcal por cm refleja esta relación entre superficie corporal y gasto energético.

El componente edad (menos 5 multiplicado por edad_años) refleja que el metabolismo basal disminuye aproximadamente 1-2% por década después de los 20 años, principalmente debido a la pérdida gradual de masa muscular (sarcopenia) y la disminución de la actividad metabólica de los órganos. En diabetes tipo 2, este factor es especialmente relevante ya que la enfermedad suele manifestarse en edades avanzadas.

El componente sexo (más 5 para hombres, menos 161 para mujeres) refleja las diferencias en composición corporal entre sexos. Los hombres típicamente tienen mayor masa muscular y menor porcentaje de grasa corporal, lo que resulta en un metabolismo basal más alto. Las mujeres, por su mayor porcentaje de grasa corporal (que es menos metabólicamente activa), tienen un TMB base menor.

### Factor de actividad física (calcular_factor_actividad)

Recibe como parámetro una cadena de texto que representa el nivel de actividad del paciente, la cual debe coincidir exactamente con una de las claves predefinidas en el diccionario de factores.

Se aplican multiplicadores estándar según el nivel de actividad reportado: Sedentario 1.2 (trabajo de escritorio, sin ejercicio), Moderado 1.4 (ejercicio ligero 1-3 días por semana), Alto 1.6 (ejercicio intenso 4-6 días por semana).

Definición de la función: La función calcular_factor_actividad implementa un diccionario estático factores que mapea strings a floats. Utiliza el método get del diccionario con valor por defecto 1.4 (moderado) para manejar casos donde la actividad no coincide exactamente con las claves esperadas. Esto proporciona robustez ante variaciones en la entrada de datos.

### Factor de ajuste para diabetes (calcular_factor_diabetes)

El algoritmo implementa una estructura de decisión que procesa cada variable clínica de manera secuencial, aplicando modificaciones incrementales al factor base (inicializado en 1.0). La implementación utiliza operadores de comparación para evaluar cada condición clínica y operadores aritméticos para aplicar los ajustes correspondientes.

Ajuste por IMC prioritario para pérdida de peso en obesidad: Si IMC mayor o igual a 35, obesidad grado II o III, se aplica déficit calórico del 25% (factor 0.75). Si IMC mayor o igual a 30, obesidad grado I, se aplica déficit calórico del 20% (factor 0.80). Si IMC menor a 18.5, bajo peso, se aumenta calorías en 10% (factor 1.1).

Ajuste adicional por HbA1c (solo si no hay obesidad): Si IMC menor a 30 y HbA1c mayor a 8.0, se reduce calorías en 10% (factor menos 0.1). Si IMC menor a 30 y HbA1c menor a 6.5, se aumenta calorías en 5% (factor más 0.05).

Ajuste adicional por glucosa en ayunas (solo si no hay obesidad): Si IMC menor a 30 y glucosa en ayunas mayor a 140 mg/dL, se reduce calorías en 5% (factor menos 0.05).

La función retorna el factor limitado entre 0.75 y 1.2 mediante max y min para prevenir ajustes extremos que puedan comprometer la seguridad nutricional del paciente.

Definición de la función: La función calcular_factor_diabetes implementa una cascada de condiciones if-elif que evalúan primero el IMC (condición más crítica), luego HbA1c y finalmente glucosa en ayunas. Cada condición modifica el factor mediante operaciones aritméticas incrementales. El resultado final se limita mediante max(0.75, min(1.2, factor)) para garantizar que el ajuste esté dentro de rangos clínicamente seguros.

### 1.1.3.4.2. Algoritmo de selección de ingredientes

#### Filtrado por seguridad (obtener_ingredientes_recomendados)

El sistema utiliza una consulta SQL que implementa múltiples condiciones de filtrado en una sola operación de base de datos, optimizando el rendimiento al reducir el número de round-trips entre la aplicación y la base de datos. La consulta implementa JOINs eficientes para recuperar información de alergias del paciente y utiliza subconsultas para verificar la ausencia de alérgenos específicos, garantizando que el filtrado se realice a nivel de base de datos donde es más eficiente.

El sistema aplica múltiples capas de filtrado: Filtro de estado: Solo ingredientes activos en la base de datos mediante condición i.activo = true. Filtro de índice glucémico: Excluye alimentos con IG mayor a umbral configurado mediante condición i.ig <= umbral. El umbral se ajusta dinámicamente según probabilidad de mal control: si probabilidad mayor a 0.7, umbral se reduce a 60; si probabilidad menor a 0.4, umbral se aumenta a 75; por defecto 70. Filtro de alergias: Elimina automáticamente alérgenos del paciente mediante LEFT JOIN con alergia y condición WHERE alergia.id IS NULL, garantizando que ningún alimento al que el paciente sea alérgico aparezca en las recomendaciones. Filtro de preferencias: Aplica exclusiones específicas del paciente mediante condiciones dinámicas que excluyen grupos alimentarios o ingredientes específicos según preferencias_incluir y preferencias_excluir del perfil.

Definición de la función: La función obtener_ingredientes_recomendados construye una consulta SQL dinámicamente mediante concatenación de strings de condiciones en una lista filtros_sql. Los parámetros se almacenan en una lista params para prevenir inyección SQL. La consulta final se ejecuta mediante fetch_all con tupla de parámetros, garantizando seguridad y eficiencia.

#### Agrupación inteligente (_agrupar_ingredientes)

Los ingredientes se clasifican en 7 grupos según la guía de intercambio de alimentos del MINSA: GRUPO1_CEREALES incluye arroz, avena, quinua, pan integral, tubérculos y legumbres. GRUPO2_VERDURAS incluye brócoli, espinaca, zanahoria, tomate. GRUPO3_FRUTAS incluye manzana, banana, naranja, uvas. GRUPO4_LACTEOS incluye leche, yogurt, queso, kéfir. GRUPO5_CARNES incluye pollo, pescado, huevo, carne de res. GRUPO6_AZUCARES incluye azúcar, miel, edulcorantes. GRUPO7_GRASAS incluye aceite de oliva, nueces, aguacate.

Definición de la función: La función _agrupar_ingredientes itera sobre la lista de ingredientes y agrupa cada ingrediente en un diccionario grupos según el campo grupo del ingrediente. Utiliza setdefault para crear listas vacías si el grupo no existe en el diccionario, luego agrega el ingrediente a la lista correspondiente. Retorna un diccionario donde las claves son nombres de grupos y los valores son listas de ingredientes.

### 1.1.3.4.3. Generación de variedad semanal

#### Algoritmo de rotación (_sugerir_desayuno_variado, _sugerir_almuerzo_variado, _sugerir_cena_variada)

Cada función de sugerencia implementa un algoritmo de variedad que utiliza un factor de variedad único por paciente. El factor se calcula mediante combinación de características del paciente (ID, edad, peso, IMC, HbA1c, glucosa) con el día de la semana y un timestamp, generando un hash MD5 que se convierte a entero para garantizar variación entre diferentes generaciones de planes.

Factor de variedad personalizado: El sistema calcula un perfil_id único combinando múltiples características mediante operaciones módulo y multiplicación por primos para distribuir valores. El cálculo incluye: (perfil.paciente_id módulo 13) multiplicado por 7, más (int(perfil.edad) módulo 11) multiplicado por 5, más (int(perfil.peso multiplicado por 10) módulo 17) multiplicado por 3, más (int(perfil.imc multiplicado por 10) módulo 19) multiplicado por 2, más (int((perfil.hba1c o 0) multiplicado por 10) módulo 23), más (int((perfil.glucosa_ayunas o 0)) módulo 29), más (dia módulo 7) multiplicado por 4, más (hash_int módulo 100). El resultado se toma módulo 1000 para mantener rango manejable, luego módulo 50 para el factor_variedad final.

Rotación cíclica por categoría: Para cereales, cereal_idx = factor_variedad módulo len(grupos['GRUPO1_CEREALES']). Para proteínas, proteina_idx = (factor_variedad más 1) módulo len(grupos['GRUPO5_CARNES']). Para verduras, verdura_idx = (factor_variedad más 2) módulo len(grupos['GRUPO2_VERDURAS']). El uso del operador módulo garantiza que el índice siempre esté dentro del rango válido de la lista, permitiendo rotación cíclica infinita.

Definición de las funciones: Las funciones _sugerir_desayuno_variado, _sugerir_almuerzo_variado y _sugerir_cena_variada implementan lógica similar pero adaptada a las necesidades nutricionales de cada tiempo de comida. Todas utilizan _filtrar_alimentos_por_repeticion para evitar repeticiones excesivas antes de seleccionar alimentos, y _agregar_alimento_con_limite para limitar cantidades y agregar segundos alimentos cuando sea necesario.

#### Distribución calórica por comida

El sistema distribuye las calorías diarias según patrones clínicos establecidos: Desayuno 25% del total calórico, Media mañana 10% del total calórico, Almuerzo 35% del total calórico, Media tarde 10% del total calórico, Cena 20% del total calórico.

Esta distribución se ajusta dinámicamente según la probabilidad de mal control glucémico predicha por ML: Si probabilidad mayor a 0.6 (mal control), se reduce desayuno a 20%, se aumenta media mañana a 12%, se aumenta almuerzo a 38%, se aumenta media tarde a 12%, se reduce cena a 18%. Esta redistribución favorece mejor control glucémico al reducir carga de carbohidratos en la mañana y distribuirla más uniformemente durante el día.

Definición de la función: La función _generar_dia_completo calcula distribucion_calorias como diccionario donde cada clave es un tiempo de comida y cada valor es el producto de metas.calorias_diarias por el porcentaje correspondiente. Si hay probabilidad_mal_control disponible y mayor a 0.6, se sobrescribe distribucion_calorias con valores ajustados. Luego, para cada tiempo de comida, se llama a _sugerir_alimentos_tiempo_variado que delega a la función específica según el tiempo.

### 1.1.3.4.4. Ajuste dinámico de cantidades

#### Función de ajuste calórico (_ajustar_cantidades_por_calorias)

Cuando se excluyen grupos alimentarios o se necesitan más calorías, el sistema ajusta automáticamente las cantidades mediante un algoritmo de escalado proporcional.

Proceso de ajuste: Cálculo de calorías actuales: Suma las calorías de los ingredientes seleccionados mediante iteración sobre alimentos y acumulación de valores kcal. Factor de ajuste: Divide calorías objetivo entre calorías actuales. Si calorías actuales es 0, factor se establece en 1.0 para evitar división por cero. Aplicación de límites: Factor limitado entre 0.5 y 2.0 para evitar cantidades extremas que puedan resultar en porciones no realistas o nutricionalmente desbalanceadas. Escalado proporcional: Aplica el factor a todas las cantidades de ingredientes mediante multiplicación de cantidad_sugerida por factor, manteniendo proporciones relativas entre alimentos.

Definición de la función: La función _ajustar_cantidades_por_calorias recibe una lista de alimentos y un objetivo calórico. Calcula total_calorias_actual mediante sumatoria. Calcula factor = objetivo_calorias / total_calorias_actual si total_calorias_actual mayor a 0, sino factor = 1.0. Limita factor = max(0.5, min(2.0, factor)). Itera sobre alimentos y actualiza cantidad_sugerida = cantidad_sugerida multiplicado por factor. Recalcula valores nutricionales (kcal, cho, pro, fat, fibra) proporcionalmente multiplicando por factor.

#### Sistema de límites de cantidad por alimento

El sistema implementa límites máximos de cantidad por alimento para prevenir porciones excesivas: GRUPO1_CEREALES máximo 200 gramos por alimento, GRUPO2_VERDURAS máximo 300 gramos por alimento, GRUPO3_FRUTAS máximo 150 gramos por alimento, GRUPO4_LACTEOS máximo 250 gramos por alimento, GRUPO5_CARNES máximo 250 gramos por alimento (no se combinan tipos diferentes), GRUPO7_GRASAS máximo 50 gramos por alimento.

Cuando se necesitan más calorías después de alcanzar el límite de un alimento, el sistema implementa lógica diferenciada según el grupo: Para GRUPO5_CARNES (carnes), solo aumenta la cantidad del mismo tipo de carne hasta el máximo de 250 gramos, nunca combina dos tipos diferentes de carne en una misma comida. Para GRUPO1_CEREALES (cereales, tubérculos, menestras), combina inteligentemente diferentes subcategorías: permite cereal más legumbre (ej: arroz más lenteja), cereal más tubérculo (ej: arroz más papa), diferentes cereales (ej: arroz más pasta), diferentes tubérculos (ej: papa más camote), pero prohíbe el mismo alimento (ej: lenteja más lenteja) y limita combinaciones de legumbres entre sí si son muy similares.

La función _agregar_alimento_con_limite implementa esta lógica: Calcula gramos necesarios mediante _convertir_porciones_a_gramos. Si excede límite, usa máximo y calcula porciones restantes. Para carnes, si hay porciones restantes, aumenta cantidad del primer alimento hasta máximo de 250 gramos. Para GRUPO1_CEREALES, si hay porciones restantes, busca alimentos combinables mediante _es_combinacion_valida_grupo1 y agrega segundo alimento. Para otros grupos, agrega segundo alimento diferente del primero.

### 1.1.3.4.5. Validaciones de seguridad

#### Controles automáticos implementados

Rango calórico: Verificación de que calorías diarias estén dentro de más menos 10% de la meta diaria. Si excede, se aplica ajuste mediante _ajustar_cantidades_por_calorias con factor limitado.

Distribución de macros: Verificación de que porcentajes de CHO, PRO y FAT estén dentro de rangos clínicos para diabetes tipo 2: CHO entre 45% y 60%, PRO entre 15% y 20%, FAT entre 25% y 35%. Si algún porcentaje está fuera de rango, se registra advertencia en logs pero no se bloquea la generación (permite flexibilidad clínica).

Índice glucémico: Verificación de que todos los alimentos tengan IG menor o igual al máximo configurado. Si algún alimento excede el umbral, se excluye automáticamente antes de la generación del plan.

Exclusiones: Verificación de ausencia de grupos o alimentos excluidos mediante comparación de nombres y grupos de alimentos generados con listas de exclusiones del perfil y configuración.

Alergias: Confirmación de ausencia de alérgenos mediante verificación de que ningún alimento en el plan tenga ID coincidente con alergias registradas del paciente.

### 1.1.3.4.6. Trazabilidad y explicabilidad

#### Sistema de logging implementado

El motor registra automáticamente mediante print statements con prefijos [DEBUG], [OK], [WARN] para facilitar filtrado: Variables del perfil del paciente utilizadas (edad, sexo, peso, IMC, HbA1c, glucosa). Factores de ajuste aplicados y su justificación (ej: "Obesidad grado I (IMC 32.1): aplicando déficit calórico del 20%"). Ingredientes disponibles por grupo después de filtros (contador de ingredientes por grupo). Score de riesgo calculado (probabilidad de mal control glucémico). Ajustes de cantidades realizados (factor aplicado y razón).

#### Mensajes de explicabilidad generados

Ejemplos de mensajes automáticos generados por el sistema: "HbA1c elevado (8.5%) requiere reducción calórica para control glucémico", "Obesidad (IMC 32.1) requiere déficit calórico controlado", "Score de riesgo: medio (0.65). Ajustes aplicados: HbA1c: -10%; IMC: -10%", "Excluyendo Arroz blanco: pico glucémico predicho 185.3 mg/dL (Modelo 1)", "45 alimentos evaluados y rankeados por Modelo 2 (score de idoneidad)", "Combinación validada con Modelo 3: score de calidad 0.72".

Estos mensajes se incluyen en el campo recomendaciones_especiales del plan generado, permitiendo que el nutricionista comprenda las decisiones del sistema y pueda explicarlas al paciente.

## 1.1.3.5. Sistema de seguimiento de repeticiones

### Algoritmo de filtrado por repetición (_filtrar_alimentos_por_repeticion)

El sistema implementa un algoritmo sofisticado para evitar repeticiones excesivas de alimentos, con reglas diferenciadas según el tipo de alimento.

Para alimentos generales: Máximo 3 veces por semana (max_repeticiones = 3). Mínimo 2 días entre repeticiones (dias_minimos_entre_repeticiones = 2).

Para proteínas (GRUPO5_CARNES): Máximo 2 veces por semana (max_repeticiones_proteinas = 2). Mínimo 3 días entre repeticiones (dias_minimos_entre_proteinas = 3). Prohibición estricta de uso en días consecutivos: si un alimento proteico se usó en el día anterior (día - 1), se marca como prohibido y no se considera para selección.

Definición de la función: La función _filtrar_alimentos_por_repeticion recibe una lista de alimentos, un diccionario alimentos_usados que mapea nombre de alimento a lista de días donde se usó, el día actual, y parámetros de repetición. Clasifica alimentos en tres categorías: alimentos_priorizados (no usados o usados hace suficiente tiempo), alimentos_evitados (usados recientemente o máximo de veces alcanzado), alimentos_prohibidos (proteínas usadas en días consecutivos). Retorna lista priorizada donde alimentos no usados aparecen primero, seguidos de alimentos usados hace más tiempo, excluyendo completamente alimentos prohibidos.

### Perfil alimentario personalizado (_calcular_perfil_alimentario_paciente)

El sistema calcula un perfil alimentario único para cada paciente basado en sus características clínicas, que influye en qué tipos de alimentos se priorizan.

Ajustes según control glucémico: Si HbA1c mayor o igual a 7.0, diabetes mal controlada, se prioriza verduras (factor 1.5), se reduce frutas (factor 0.7), máximo 2 porciones de fruta por día, mínimo 5 porciones de verdura por día. Si HbA1c mayor o igual a 6.5, prediabetes o diabetes temprana, se prioriza verduras moderadamente (factor 1.2), se reduce frutas (factor 0.8), máximo 2 porciones de fruta por día.

Ajustes según glucosa en ayunas: Si glucosa mayor o igual a 140 mg/dL, se prioriza verduras (factor mínimo 1.4), se reduce frutas (factor máximo 0.6), máximo 2 porciones de fruta por día.

Ajustes según triglicéridos: Si triglicéridos mayor o igual a 150 mg/dL, se prioriza pescado (factor 1.5), se evita carnes rojas (evitar_carnes_rojas = True).

Ajustes según LDL: Si LDL mayor o igual a 130 mg/dL, se prioriza pescado (factor mínimo 1.3) para aumentar grasas insaturadas.

Ajustes según IMC: Si IMC mayor o igual a 35, obesidad severa, se prioriza verduras (factor mínimo 1.3) para volumen y saciedad, mínimo 5 porciones de verdura por día. Si IMC mayor o igual a 30, obesidad, se prioriza verduras (factor mínimo 1.2), máximo 3 porciones de fruta por día.

Definición de la función: La función _calcular_perfil_alimentario_paciente inicializa un diccionario perfil_alimentario con valores por defecto (factores en 1.0, booleanos en False). Luego aplica una cascada de condiciones if que modifican estos valores según características clínicas del paciente. Utiliza max y min para asegurar que factores no se reduzcan o aumenten más allá de límites razonables cuando múltiples condiciones se cumplen simultáneamente.

## 1.1.3.6. Algoritmos para la generación del plan nutricional

### Proceso de generación semanal

El sistema implementa un algoritmo de generación de planes que combina la selección inteligente de ingredientes con la distribución calórica por comidas. El proceso se ejecuta en las siguientes etapas:

Etapa 1: Inicialización del plan. Se calculan las calorías objetivo por comida según la distribución establecida mediante multiplicación de metas.calorias_diarias por porcentajes fijos o ajustados por ML. Se obtienen los ingredientes filtrados por seguridad y preferencias mediante obtener_ingredientes_recomendados que aplica todos los filtros (IG, alergias, exclusiones). Se agrupan los ingredientes por categorías alimentarias mediante _agrupar_ingredientes que retorna diccionario con claves de grupos y valores de listas de ingredientes.

Etapa 2: Generación por días. Para cada día de la semana (1 a dias), se ejecuta el algoritmo de rotación mediante _generar_dia_variado. Se seleccionan ingredientes variados para cada tiempo de comida mediante funciones _sugerir_desayuno_variado, _sugerir_almuerzo_variado, _sugerir_cena_variada, _sugerir_merienda_variada. Se aplican las cantidades sugeridas según el tipo de alimento mediante _convertir_porciones_a_gramos que convierte porciones de intercambio a gramos basándose en porciones_intercambio del ingrediente o valores nutricionales estándar.

Etapa 3: Validación y ajuste. Se verifica el cumplimiento de las metas calóricas por comida mediante comparación de calorías totales de alimentos seleccionados con objetivo calórico del tiempo de comida. Si hay desviación mayor a 10%, se aplica _ajustar_cantidades_por_calorias. Se valida la ausencia de alérgenos y grupos excluidos mediante iteración sobre alimentos generados y verificación contra listas de exclusiones. Se calculan los totales nutricionales diarios y semanales mediante _generar_resumen_semanal que suma valores nutricionales de todos los alimentos en todos los días.

### Algoritmo de selección de ingredientes por comida

El algoritmo implementa los siguientes pasos para cada tiempo de comida:

Paso 1: Calcular porciones necesarias mediante _calcular_porciones_para_comida que determina cuántas porciones de intercambio de cada grupo se necesitan para alcanzar las calorías objetivo del tiempo de comida, basándose en estándares de la guía de intercambio.

Paso 2: Filtrar alimentos por repetición mediante _filtrar_alimentos_por_repeticion que elimina alimentos usados recientemente o que alcanzaron máximo de repeticiones, priorizando alimentos no usados.

Paso 3: Aplicar perfil alimentario mediante _calcular_perfil_alimentario_paciente que ajusta factores de priorización según características clínicas, luego se multiplican porciones por estos factores.

Paso 4: Seleccionar alimentos mediante _agregar_alimento_con_limite que selecciona primer alimento usando factor_variedad módulo longitud de lista, calcula gramos necesarios, aplica límites máximos, y agrega segundo alimento si es necesario (según reglas de combinación).

Paso 5: Evaluar con Modelo 1 (Predicción de Respuesta Glucémica) mediante predecir_respuesta_glucemica para cada alimento candidato. La función prepara features del paciente y del alimento, escala mediante StandardScaler, y realiza predicción con modelos XGBoost Regressor para glucose_increment, glucose_peak y time_to_peak. Si glucose_peak predicho mayor a 180 mg/dL, se excluye el alimento automáticamente. Paso 6: Calcular score de idoneidad con Modelo 2 (Selección Personalizada) mediante calcular_score_idoneidad_alimento para cada alimento candidato restante. La función prepara features del paciente y del alimento, escala mediante StandardScaler del modelo, y realiza predicción con XGBoost Classifier que retorna probabilidad de que el alimento sea adecuado (0-1). Se ordenan alimentos por score descendente, priorizando aquellos con mayor idoneidad para el perfil del paciente.

### Estrategia de variedad semanal

Factor de variedad personalizado: El sistema calcula un factor único por paciente y día mediante combinación de características del paciente con día de la semana y hash MD5 de timestamp. Esto garantiza que diferentes generaciones de planes para el mismo paciente produzcan diferentes selecciones de alimentos, mientras que el mismo paciente en el mismo día siempre obtiene la misma selección (determinismo para debugging).

Rotación cíclica por categoría: Cereales: cereal_idx = factor_variedad módulo len(cereales_ordenados). Proteínas: proteina_idx = (factor_variedad más 1) módulo len(proteinas_filtradas). Verduras: verdura_idx = (factor_variedad más 2) módulo len(verduras_filtradas). El uso de offsets diferentes (0, 1, 2) garantiza que diferentes grupos seleccionen alimentos diferentes incluso con el mismo factor_variedad base.

Algoritmo de generación diaria (_generar_dia_variado): La función recibe grupos de alimentos, día, metas, configuración, perfil, alimentos_usados y parámetros de repetición. Define orden correcto de comidas como lista ['des', 'mm', 'alm', 'mt', 'cena']. Para cada tiempo en orden_comidas, calcula calorias_objetivo desde distribucion_calorias. Llama a _sugerir_alimentos_tiempo_variado que delega a función específica según tiempo. Actualiza seguimiento de alimentos_usados agregando día actual a lista de días donde se usó cada alimento. Calcula totales nutricionales sumando valores de alimentos sugeridos. Construye estructura de comida con alimentos, totales y fecha. Retorna diccionario con claves de tiempos de comida y valores de estructuras de comida.

## 1.1.3.7. Modelos de ML: entrenamiento, validación e inferencia

El sistema implementa tres modelos ML especializados, cada uno entrenado con datasets específicos y optimizado para una tarea particular dentro del flujo de recomendación nutricional.

### Modelo 1: Predicción de Respuesta Glucémica Postprandial

Construcción del dataset: Se utiliza dataset modelo1_respuesta_glucemica.csv preparado mediante script preparar_datos_modelo1_respuesta_glucemica.py que procesa datos de CGMacros. Para cada comida registrada, se calcula respuesta glucémica postprandial: glucose_baseline (promedio de glucosa 30 minutos antes), glucose_peak (pico en ventana de 3 horas después), glucose_increment (diferencia peak - baseline), time_to_peak (tiempo hasta el pico), glucose_2h (glucosa a las 2 horas), glucose_auc (área bajo la curva). Inputs: perfil del paciente (edad, sexo, IMC, peso, talla, datos bioquímicos), características del alimento (kcal, CHO, PRO, FAT, fibra), features derivadas (CHO por 100 kcal, PRO por 100 kcal, FAT por 100 kcal, fibra por 100 kcal), contexto (hora, tipo de comida, tiempo desde última comida, actividad física antes). Targets: glucose_increment (regresión continua en mg/dL), glucose_peak (regresión continua en mg/dL), time_to_peak (regresión continua en minutos).

Algoritmo y entrenamiento: Se utiliza XGBoost Regressor con configuración n_estimators=200, max_depth=6, learning_rate=0.1, subsample=0.8, colsample_bytree=0.8. Se entrena un modelo separado para cada target (glucose_increment, glucose_peak, time_to_peak) mediante script entrenar_modelo1_respuesta_glucemica.py. Se utiliza StandardScaler para normalizar features antes del entrenamiento. División de datos: 80% entrenamiento, 20% prueba mediante train_test_split con random_state=42. Métricas de evaluación: MAE (Mean Absolute Error), RMSE (Root Mean Squared Error), R2 score para cada target. El modelo se guarda en formato pickle junto con scaler y metadata (feature_columns, target_columns) en ApartadoInteligente/ModeloML/modelo_respuesta_glucemica.pkl y scaler_respuesta_glucemica.pkl.

Inferencia e integración: Durante la generación del plan, se utiliza función predecir_respuesta_glucemica que recibe perfil del paciente, alimento candidato y contexto. La función prepara features, escala mediante StandardScaler cargado, y realiza predicción con los tres modelos (glucose_increment, glucose_peak, time_to_peak). Si glucose_peak predicho mayor a 180 mg/dL, el alimento se excluye automáticamente antes de incluirlo en el plan. Esto previene recomendaciones que causarían hiperglucemia postprandial excesiva.

### Modelo 2: Selección Personalizada de Alimentos

Construcción del dataset: Se utiliza dataset modelo2_seleccion_alimentos.csv preparado mediante script preparar_datos_modelo2_seleccion_alimentos.py que combina datos de MyFitnessPal y CGMacros. Para cada alimento de MyFitnessPal, se busca perfil nutricional similar en CGMacros y se calcula respuesta glucémica promedio. Se calcula score de idoneidad (0-1) basado en: respuesta glucémica (50% del score: menor incremento = mejor), frecuencia de consumo (30% del score: más consumo = mejor, indica preferencia), preferencia explícita si está disponible (20% del score). Inputs: perfil del paciente (edad, sexo, IMC, HbA1c, glucosa en ayunas), características del alimento (kcal, CHO, PRO, FAT, sodio, azúcar), features derivadas (CHO por 100 kcal, PRO por 100 kcal, FAT por 100 kcal), frecuencia de consumo. Target: score_idoneidad (clasificación binaria: score mayor a 0.6 = adecuado, menor o igual a 0.6 = no adecuado).

Algoritmo y entrenamiento: Se utiliza XGBoost Classifier con configuración n_estimators=200, max_depth=6, learning_rate=0.1, subsample=0.8, colsample_bytree=0.8, eval_metric='logloss'. Se entrena mediante script entrenar_modelo2_seleccion_alimentos.py. Se utiliza StandardScaler para normalizar features. División de datos: 80% entrenamiento, 20% prueba con estratificación para mantener distribución de clases. Métricas de evaluación: Accuracy, Precision, Recall, F1-score, AUC-ROC para clasificación binaria. El modelo se guarda en formato pickle junto con scaler y metadata (feature_columns, umbral_score) en ApartadoInteligente/ModeloML/modelo_seleccion_alimentos.pkl.

Inferencia e integración: Durante la selección de alimentos, se utiliza función calcular_score_idoneidad_alimento que recibe perfil del paciente y alimento candidato. La función prepara features, escala mediante StandardScaler cargado, y realiza predicción con XGBoost Classifier que retorna probabilidad de que el alimento sea adecuado (0-1). Los alimentos se ordenan por score descendente antes de la selección, priorizando aquellos con mayor idoneidad para el perfil del paciente.

### Modelo 3: Optimización de Combinaciones de Alimentos

Construcción del dataset: Se utiliza dataset modelo3_combinaciones.csv preparado mediante script preparar_datos_modelo3_combinaciones.py que procesa datos de CGMacros. Se agrupan comidas del mismo día que están cercanas en tiempo (dentro de 1 hora) para representar "comidas completas" con varios platos. Se calculan características agregadas de la combinación: totales nutricionales (kcal, CHO, PRO, FAT, fibra), proporciones (porcentaje de cada macronutriente), diversidad (número de tipos de comida diferentes). Se calcula respuesta glucémica total de la combinación mediante función calcular_respuesta_combinacion que analiza ventana de 3 horas desde la primera comida. Se calcula score de calidad (0-1) basado en incremento de glucosa (70% del score) y variabilidad de glucosa (30% del score). Inputs: perfil del paciente (edad, sexo, IMC, HbA1c, glucosa en ayunas), características de la combinación (totales nutricionales, proporciones, diversidad), contexto (hora de la primera comida, duración de la combinación). Target: score_calidad (regresión continua 0-1).

Algoritmo y entrenamiento: Se utiliza Ensemble que combina XGBoost Regressor y Random Forest Regressor, promediando sus predicciones. XGBoost Regressor con configuración n_estimators=200, max_depth=6, learning_rate=0.1. Random Forest Regressor con configuración n_estimators=200, max_depth=10, min_samples_split=5, min_samples_leaf=2. Se entrena mediante script entrenar_modelo3_combinaciones.py. Se utiliza StandardScaler para normalizar features. División de datos: 80% entrenamiento, 20% prueba. Métricas de evaluación: MAE, RMSE, R2 score para regresión. Se evalúan ambos modelos individualmente y el ensemble (promedio de predicciones). El ensemble generalmente muestra mejor rendimiento que los modelos individuales. El modelo se guarda en formato pickle junto con scaler y metadata (feature_columns, métricas de ambos modelos y ensemble) en ApartadoInteligente/ModeloML/modelo_optimizacion_combinaciones.pkl.

Inferencia e integración: Durante la optimización del plan, se utiliza función evaluar_combinacion_alimentos que recibe perfil del paciente y combinación de alimentos. La función prepara features de la combinación (totales nutricionales, proporciones, diversidad), escala mediante StandardScaler cargado, y realiza predicción con el ensemble (promedio de predicciones de XGBoost y Random Forest). Se retorna score de calidad (0-1). Si score menor a 0.6, la combinación se considera de baja calidad y se busca alternativa. Esto valida que las combinaciones sugeridas durante la optimización tengan calidad nutricional adecuada.

### Carga y gestión de modelos

Carga bajo demanda: Los tres modelos se cargan bajo demanda cuando se necesitan, no al inicializar el motor. Esto optimiza uso de memoria y tiempo de inicio de la aplicación. Se implementa mediante flags _modelo_respuesta_glucemica, _modelo_seleccion_alimentos, _modelo_optimizacion_combinaciones que se inicializan en None y se cargan en primera llamada a funciones de predicción correspondientes.

Rutas de modelos: Los modelos se cargan desde rutas relativas: ApartadoInteligente/ModeloML/modelo_respuesta_glucemica.pkl y scaler_respuesta_glucemica.pkl para Modelo 1, ApartadoInteligente/ModeloML/modelo_seleccion_alimentos.pkl para Modelo 2 (scaler incluido en el archivo), ApartadoInteligente/ModeloML/modelo_optimizacion_combinaciones.pkl para Modelo 3 (scaler incluido en el archivo). Las rutas se calculan desde la raíz del proyecto mediante Path(__file__).parent.parent para garantizar portabilidad.

Manejo de errores: Si un modelo no está disponible (archivo no encontrado o error al cargar), el sistema continúa funcionando con reglas basadas en conocimiento, registrando advertencias en logs. Esto garantiza que el sistema siempre funcione, incluso si los modelos ML no están disponibles, manteniendo robustez y confiabilidad.

### Validación de modelos

Modelo 1: Se evalúa mediante métricas de regresión en conjunto de prueba. Típicamente alcanza R2 score de 0.78 en predicción de glucose_peak, con MAE de 12.3 mg/dL. Esto indica que el modelo puede predecir picos glucémicos con precisión razonable, suficiente para excluir alimentos problemáticos.

Modelo 2: Se evalúa mediante métricas de clasificación en conjunto de prueba. Típicamente alcanza AUC-ROC de 0.85 en clasificación de idoneidad, con accuracy de 0.82. Esto indica que el modelo puede distinguir efectivamente entre alimentos adecuados y no adecuados para diferentes perfiles de pacientes.

Modelo 3: Se evalúa mediante métricas de regresión en conjunto de prueba. Típicamente alcanza R2 score de 0.81 en predicción de score de calidad, con MAE de 0.08. El ensemble generalmente muestra mejor rendimiento que los modelos individuales, validando la estrategia de combinación.

### Inferencia e impacto en el plan

Modelo 1 (Respuesta Glucémica): Impacto directo en seguridad: excluye alimentos que causarían picos glucémicos excesivos (mayor a 180 mg/dL) antes de incluirlos en el plan. Esto previene recomendaciones que podrían causar hiperglucemia postprandial peligrosa. Se utiliza durante la selección de alimentos, evaluando cada alimento candidato antes de la selección final.

Modelo 2 (Selección Personalizada): Impacto en personalización: prioriza alimentos más adecuados para el perfil específico del paciente mediante ranking por score de idoneidad. Esto mejora la relevancia y aceptabilidad de las recomendaciones. Se utiliza durante la selección de alimentos, ordenando candidatos por idoneidad antes de aplicar algoritmo de rotación.

Modelo 3 (Optimización de Combinaciones): Impacto en calidad nutricional: valida que las combinaciones sugeridas durante la optimización tengan calidad adecuada (score mayor a 0.6). Esto asegura que las combinaciones no solo cumplan objetivos nutricionales cuantitativos, sino que también tengan calidad nutricional adecuada. Se utiliza durante la optimización del plan, validando combinaciones sugeridas por el optimizador antes de aceptarlas.

Integración coordinada: Los tres modelos trabajan en secuencia durante la generación del plan. Primero, Modelo 1 excluye alimentos problemáticos. Segundo, Modelo 2 rankea alimentos restantes por idoneidad. Tercero, después de generar el plan, Modelo 3 valida calidad de combinaciones durante la optimización. Esta integración coordinada mejora tanto la seguridad como la personalización y calidad de las recomendaciones.

## 1.1.3.8. Generación del plan y controles de seguridad

Selección y variedad: Las funciones _sugerir_desayuno_variado, _sugerir_almuerzo_variado y _sugerir_cena_variada rotan cereales, proteínas, frutas y verduras por día, evitando repeticiones inmediatas mediante _filtrar_alimentos_por_repeticion y respetando grupos excluidos mediante verificación de nombre de grupo contra lista de exclusiones.

Ajuste cuantitativo: Balance por comida hacia calorías objetivo del tiempo mediante _ajustar_cantidades_por_calorias que calcula factor de ajuste y lo aplica proporcionalmente a todas las cantidades, sin exceder topes de porción definidos en _obtener_limites_cantidad_grupo.

Validaciones automáticas (por día y semana): Calorías: Verificación de que estén dentro de más menos 10% de meta mediante comparación de totales calculados con metas.calorias_diarias. Macronutrientes: Reporte de porcentaje efectivo versus meta mediante cálculo de porcentajes reales y comparación con rangos clínicos. IG: Verificación de que máximo observado sea menor o igual a umbral configurado mediante iteración sobre alimentos y comparación de campo ig. Respeto de exclusiones: Verificación de ausencia de grupos o alimentos excluidos mediante comparación de nombres y grupos. Ausencia de alérgenos: Confirmación mediante verificación de que ningún alimento tenga ID coincidente con alergias. Variedad: Cálculo de porcentaje de platos distintos por tiempo mediante conteo de combinaciones únicas de alimentos y división por total de comidas.

## 1.1.3.9. Interfaz y experiencia de usuario

Panel de autenticación (login.html): Propósito: Punto de entrada seguro al sistema. Características: Diseño moderno con panel dividido con branding y formulario. Flexibilidad de login acepta DNI o email como usuario mediante campo de texto que se valida en backend para determinar tipo de identificador. Características visuales incluyen formas flotantes, iconos Font Awesome, mensajes de error con estilos de alerta. Seguridad mediante validación de contraseñas en frontend (longitud mínima) y backend (hash verification), manejo de sesiones con Flask session que almacena user_id y user_email.

Panel de Administración Principal (admin_index.html): Propósito: Dashboard central para administradores y nutricionistas. Características: Grid de módulos con acceso rápido a todas las funcionalidades del sistema mediante tarjetas con iconos y descripciones. Navegación intuitiva con iconos y tarjetas para cada módulo (Usuarios, Pacientes, Planes, Ingredientes, Clínico, Antropometría). Diseño responsive que se adapta a diferentes tamaños de pantalla mediante CSS Grid y Flexbox.

Gestión de pacientes (pacientes_list.html): Propósito: Administración integral de pacientes del hospital. Características: Búsqueda avanzada por DNI, nombre o apellido con sugerencias en tiempo real mediante endpoint /api/pacientes/buscar que retorna resultados mientras el usuario escribe, con debounce de 300ms para reducir carga del servidor. Modal de registro completo con tabs para datos personales, antropometría y clínicos, permitiendo captura de toda la información en una sola interfaz. Tabla dinámica con paginación mediante endpoint /api/pacientes/page que retorna 10 pacientes por página, filtros y acciones por paciente (ver detalle, editar, eliminar).

Generar plan nutricional (obtener_plan.html): Propósito: Interfaz principal para generar y visualizar planes nutricionales. Características: Configuración del plan con fechas (inicio y fin), objetivos calóricos (input numérico), distribución de macronutrientes (sliders o inputs numéricos para CHO, PRO, FAT porcentajes), IG máximo (input numérico con validación de rango 0-100). Filtros de exclusión por grupos alimentarios con checkboxes para cada grupo de la guía de intercambio, nomenclatura oficial (GRUPO1_CEREALES, etc.). Ingredientes específicos con funcionalidad de incluir o excluir mediante buscador inteligente que consulta /api/ingredientes/activos con query parameter q para búsqueda por nombre. Vista previa multi-formato con Lista (formato vertical con alimentos por comida), Horario (formato de tabla con horas y alimentos), y Tabla Semanal (formato de grid con días como columnas y comidas como filas) con paginación mediante JavaScript que divide semanas en páginas. Acciones del plan con botones para Guardar borrador (estado "borrador"), Publicar (estado "publicado") y Descargar PDF (generación de documento mediante biblioteca de PDF en frontend o endpoint backend).

Detalle del plan (plan_detalle.html): Propósito: Vista detallada de planes nutricionales guardados. Características: Información del plan con estado (badge visual con colores: verde para publicado, amarillo para borrador), fechas (inicio y fin formateadas), creador (nombre del nutricionista o admin que generó el plan). Vista por días con planificación diaria con comidas y alimentos, cada alimento mostrado con nombre, cantidad en gramos, y valores nutricionales (kcal, CHO, PRO, FAT). Información nutricional con calorías y macronutrientes por alimento mostrados en formato de tarjetas con iconos y colores diferenciados. Recomendaciones con notas adicionales para el paciente extraídas del campo recomendaciones_especiales del plan, mostradas en sección destacada.

