# 1.1.4. Iteración 4: Evaluación e Integración del Modelo (CRISP-DM) + Sprint 4 (SCRUM)

## 1.1.4.1. Propósito y alcance del sprint

El objetivo de este cuarto sprint fue evaluar el funcionamiento del sistema de recomendación nutricional mediante pruebas funcionales exhaustivas, integrar los modelos ML en tiempo de ejecución, implementar el optimizador de planes para mejorar precisión en el cumplimiento de objetivos nutricionales, y desarrollar mejoras en la interfaz de usuario basadas en feedback de iteraciones anteriores.

Se definió un alcance centrado en la validación del sistema completo mediante pruebas funcionales que verifican comportamiento correcto de todas las funcionalidades implementadas, la integración de los tres modelos ML (Predicción de Respuesta Glucémica, Selección Personalizada de Alimentos, Optimización de Combinaciones) en el flujo de generación de planes, la implementación del módulo OptimizadorPlan que ajusta iterativamente los planes para cumplir objetivos nutricionales con mayor precisión, y mejoras en la experiencia de usuario mediante corrección de bugs y optimización de interfaces.

El foco técnico se centró en garantizar que el sistema funcione de manera robusta y confiable, con manejo adecuado de errores, validaciones exhaustivas, y integración fluida entre componentes del sistema (frontend, backend, modelos ML, base de datos).

## 1.1.4.2. Pruebas de caja negra

Se realizaron pruebas de caja negra para verificar la correcta implementación de estructuras de control (condicionales, bucles) en los componentes críticos del sistema desarrollados durante este sprint. Las pruebas se enfocaron en validar la lógica interna del código mediante revisión del código fuente, asegurando que las estructuras condicionales y bucles funcionen correctamente según los requisitos establecidos.

### Prueba PCN01: Estructuras condicionales en OptimizadorPlan

Se verificó mediante revisión de código la implementación del bucle de optimización en la función optimizar_plan del módulo Core/optimizador_plan.py. La prueba validó que el bucle for itera correctamente hasta máximo 20 iteraciones (línea 215), que la estructura condicional if cumplimiento.cumple_objetivos (línea 227) permite saltar días que ya cumplen objetivos mediante continue, que la estructura condicional if exceso_significativo (línea 240) detecta correctamente cuando algún macronutriente excede 100% y aplica reducción, y que la estructura condicional if mejoras_en_iteracion == 0 (línea 312) detiene el bucle cuando no hay mejoras en una iteración completa. Resultado: Todas las estructuras condicionales están correctamente implementadas y funcionan según lo esperado.

### Prueba PCN02: Estructuras condicionales en carga de modelos ML

Se verificó mediante revisión de código la implementación de las funciones de carga de modelos ML (_cargar_modelo_respuesta_glucemica, _cargar_modelo_seleccion_alimentos, _cargar_modelo_optimizacion_combinaciones) en el módulo Core/motor_recomendacion.py. La prueba validó que la estructura condicional if self._modelo_respuesta_glucemica is not None (línea 198) previene recarga innecesaria de modelos ya cargados, que la estructura condicional if not ML_AVAILABLE (línea 202) permite fallback a sistema basado en reglas cuando las dependencias ML no están disponibles, que la estructura condicional if not modelo_path.exists() (línea 214) maneja correctamente la ausencia de archivos de modelos, y que las estructuras try-except (línea 208) capturan y manejan errores de carga sin interrumpir el funcionamiento del sistema. Resultado: Todas las estructuras condicionales están correctamente implementadas y el sistema maneja adecuadamente casos de error.

### Prueba PCN03: Estructuras condicionales anidadas en _determinar_control_glucemico

Se verificó mediante revisión de código la implementación de la función _determinar_control_glucemico en el módulo main.py. La prueba validó que la estructura condicional if prob_final is None (línea 4792) prioriza correctamente probabilidad_ajustada sobre probabilidad_ml, que las estructuras condicionales anidadas clasifican correctamente según umbrales: if prob_final > 0.6 retorna 'MALO' (línea 4797), elif prob_final > 0.4 retorna 'MODERADO' (línea 4799), else retorna 'BUENO' (línea 4801), que las estructuras condicionales de fallback clínico verifican correctamente valores de HbA1c y glucosa: if perfil.hba1c >= 7.0 retorna 'MALO' (línea 4806), if perfil.glucosa_ayunas >= 140 retorna 'MALO' (línea 4808), if perfil.hba1c >= 6.5 retorna 'MODERADO' (línea 4812), y que todas las rutas de código retornan un valor válido (BUENO, MODERADO o MALO). Resultado: Las estructuras condicionales anidadas implementan correctamente la priorización y clasificación de control glucémico.

### Resumen de resultados de pruebas de caja negra

Todas las 3 pruebas de caja negra fueron ejecutadas y validadas mediante revisión de código. Los resultados confirman que las estructuras condicionales y bucles están correctamente implementadas en todos los componentes críticos del sistema. Las pruebas validaron la lógica interna de: optimización iterativa de planes, carga bajo demanda de modelos ML, y determinación de control glucémico. Todas las estructuras de control funcionan según los requisitos establecidos y manejan adecuadamente casos límite y errores.

## 1.1.4.3. Pruebas de caja blanca

Se realizaron pruebas de caja blanca para verificar el comportamiento externo del sistema mediante peticiones HTTP usando Postman o DevTools del navegador. Las pruebas se enfocaron en validar que los endpoints respondan correctamente a las peticiones, que los datos se envíen y reciban en el formato esperado, y que el sistema funcione correctamente desde la perspectiva del usuario final sin conocer la implementación interna.

### Prueba PCB01: Generación de plan nutricional con exclusión de grupos alimentarios

Se verificó mediante petición HTTP POST a /api/recomendacion/generar que el sistema respeta la exclusión de grupos alimentarios. La prueba se realizó enviando un body JSON con grupos_excluidos: ["GRUPO6_AZUCARES"] y verificando en la respuesta que ningún alimento del grupo excluido aparece en el plan generado. Se utilizó Postman o DevTools del navegador para capturar la petición y respuesta HTTP. Se validó que el status code es 200 OK, que la respuesta contiene plan_completo con estructura correcta, y que al inspeccionar el JSON de respuesta ningún alimento tiene grupo igual a "GRUPO6_AZUCARES". Resultado: El endpoint respeta correctamente las exclusiones de grupos alimentarios y retorna planes sin alimentos del grupo excluido.

### Prueba PCB02: Configuración inteligente con ajuste ML según control glucémico

Se verificó mediante petición HTTP GET a /api/recomendacion/configuracion/<paciente_id> que el sistema retorna configuración base y configuración final ajustada por ML. La prueba se realizó para tres pacientes con diferentes niveles de control glucémico (BUENO, MODERADO, MALO) y se verificó en las respuestas que los valores de IG máximo y repeticiones máximas se ajustan correctamente según la clasificación. Se utilizó Postman o DevTools para capturar las peticiones y respuestas. Se validó que el status code es 200 OK, que la respuesta contiene configuracion_base, configuracion_final y objeto ml con control_glucemico, y que los valores de ig_max y repeticiones_maximas coinciden con los esperados según el control glucémico. Resultado: El endpoint retorna correctamente configuración ajustada por ML y clasificación de control glucémico.

### Prueba PCB03: Guardado de plan nutricional en base de datos

Se verificó mediante petición HTTP POST a /api/planes que el sistema guarda planes nutricionales en la base de datos. La prueba se realizó enviando un body JSON con estructura completa del plan y verificando que el sistema retorna ID del plan guardado y URL de detalle. Se utilizó Postman o DevTools para capturar la petición y respuesta. Se validó que el status code es 200 OK, que la respuesta contiene ok: true, id: [número] y detalle_url: "/planes/[id]", y que al realizar petición GET a la URL de detalle se recupera correctamente el plan guardado. Resultado: El endpoint guarda correctamente los planes en la base de datos y permite recuperarlos mediante la URL de detalle.

### Resumen de resultados de pruebas de caja blanca

Todas las 3 pruebas de caja blanca fueron ejecutadas y validadas mediante peticiones HTTP. Los resultados confirman que los endpoints funcionan correctamente y responden según lo esperado. Las pruebas validaron el comportamiento externo de: generación de planes con exclusiones, configuración inteligente con ajuste ML, y persistencia de planes en base de datos. Todas las peticiones HTTP retornan status codes correctos y datos en el formato esperado.

## 1.1.4.3. Pruebas funcionales clave

Exclusión de grupos: Se corrigió el colector de checkboxes en el frontend mediante JavaScript que itera sobre elementos con clase checkbox-grupo y recopila valores marcados en array grupos_excluidos. La propagación al backend se implementa mediante serialización JSON en el body de la petición POST a /api/recomendacion/generar. Se verificó que el grupo excluido no aparece en el plan mediante validación en obtener_ingredientes_recomendados que filtra ingredientes por grupo antes de la selección.

Variedad multi día: El plan deja de repetir el mismo menú mediante implementación de sistema de seguimiento de alimentos_usados que almacena días donde cada alimento fue utilizado. Se realizaron ajustes en el endpoint para usar perfil real del paciente mediante llamada a obtener_perfil_paciente que carga datos actualizados desde la base de datos antes de generar el plan.

Ajuste calórico: La función _ajustar_cantidades_por_calorias corrige cantidades cuando el set de alimentos se reduce por exclusiones mediante cálculo de factor de ajuste que divide calorías objetivo entre calorías actuales, limitado entre 0.5 y 2.0 para evitar cantidades extremas. El factor se aplica proporcionalmente a todas las cantidades de ingredientes, manteniendo proporciones relativas.

Incluir alimentos: Ahora prioriza su selección mediante modificación de _filtrar_alimentos_por_repeticion que verifica si un alimento está en lista de preferencias_incluir del perfil. Si está incluido, se agrega al inicio de la lista de alimentos priorizados, sin forzar todos los días o comidas. La búsqueda flexible por nombre se implementa mediante endpoint /api/ingredientes/activos con query parameter q que realiza búsqueda ILIKE en PostgreSQL, con fallback al catálogo completo si no hay resultados.

Paginación multi semana: Se corrigieron índices en JavaScript mediante cálculo correcto de página actual y total de páginas basado en número de días del plan dividido por 7. La navegación Anterior y Siguiente se implementa mediante funciones JavaScript que actualizan índice de semana actual y recalculan rango de días a mostrar.

Persistencia de planes: Guardado en JSON mediante endpoint /api/planes que recibe estructura completa del plan en campo plan del body. Se implementan estados Borrador y Publicado mediante campo estado que se almacena en tabla plan. La vista de detalle se implementa mediante endpoint /planes/<plan_id> que carga plan desde base de datos y renderiza template plan_detalle.html.

## 1.1.4.4. Evidencia (capturas/flujo)

Generación con y sin exclusión de grupos: Se documentó flujo completo de generación de plan con exclusión de GRUPO6_AZUCARES mediante captura de pantalla de interfaz de configuración mostrando checkbox marcado. Se verificó que ningún alimento del grupo excluido aparece en el plan generado mediante inspección de estructura JSON retornada por API. Se documentó flujo de generación sin exclusiones mediante captura de pantalla mostrando todos los grupos disponibles.

Verificación de calorías por comida: Se documentó cálculo de calorías por comida mediante captura de pantalla de vista de plan mostrando totales nutricionales por tiempo de comida. Se verificó que calorías por comida están dentro de distribución esperada (desayuno 25%, media mañana 10%, almuerzo 35%, media tarde 10%, cena 20%) mediante comparación de valores mostrados con metas calculadas.

Vista previa en los tres formatos: Se documentó formato Lista mediante captura de pantalla mostrando alimentos en formato vertical con información nutricional. Se documentó formato Horario mediante captura de pantalla mostrando tabla con horas y alimentos correspondientes. Se documentó formato Tabla Semanal mediante captura de pantalla mostrando grid con días como columnas y comidas como filas, con paginación funcional.

Publicación y apertura del detalle del plan: Se documentó flujo de publicación mediante captura de pantalla de botón Publicar y confirmación de cambio de estado. Se documentó apertura del detalle mediante captura de pantalla de vista plan_detalle.html mostrando información completa del plan, alimentos por día y recomendaciones especiales.

## 1.1.4.5. Métricas de aceptación (definidas para evaluación continua)

Cumplimiento de kcal objetivo por comida y día: Se define cumplimiento como porcentaje de calorías reales dividido entre calorías objetivo, multiplicado por 100. Se considera aceptable si está dentro de más menos 10% de la meta (90% a 110%). Se implementa cálculo mediante función calcular_cumplimiento_dia en OptimizadorPlan que suma calorías de todos los alimentos en todas las comidas del día y compara con meta diaria.

Variedad semanal: Se define variedad como porcentaje de combinaciones únicas de alimentos por tiempo de comida dividido entre total de comidas del tiempo, multiplicado por 100. Se considera aceptable si es mayor a 60% (más de la mitad de las comidas son diferentes). Se implementa cálculo mediante función _calcular_variedad_semanal que cuenta combinaciones únicas de alimentos por tiempo de comida.

Respeto de exclusiones y límites de IG: Se define respeto como ausencia de grupos o alimentos excluidos en el plan generado. Se verifica mediante iteración sobre alimentos generados y comparación de nombre de grupo y nombre de alimento contra listas de exclusiones. Se considera aceptable si 100% de exclusiones son respetadas (cero violaciones). Se implementa verificación mediante función _validar_exclusiones que retorna lista de violaciones encontradas.

Tasa de generación sin errores: Se define tasa como número de planes generados exitosamente dividido entre número total de intentos de generación, multiplicado por 100. Se considera aceptable si es mayor a 95% (menos de 5% de fallos). Se implementa registro mediante logging de excepciones en endpoint /api/recomendacion/generar con contador de éxitos y fallos.

## 1.1.4.6. Integración del optimizador de planes

El sistema implementa un módulo OptimizadorPlan que ajusta iterativamente los planes generados para cumplir objetivos nutricionales con mayor precisión.

Funcionalidad del optimizador: El optimizador recibe un plan semanal generado, metas nutricionales, grupos de alimentos disponibles, perfil del paciente y motor de recomendación. Calcula cumplimiento inicial de cada día mediante función calcular_cumplimiento_dia que suma valores nutricionales de todos los alimentos y compara con metas. Itera hasta máximo de 20 iteraciones o hasta que todos los días cumplan objetivos (promedio mayor o igual a 90% y todos los macronutrientes entre 83% y 100%).

Algoritmo de optimización: Para cada día que no cumple objetivos, identifica déficits de macronutrientes mediante cálculo de diferencia entre porcentaje actual y 90% objetivo. Prioriza ajustes según orden: primero grasas (GRUPO7_GRASAS), luego proteínas (GRUPO5_CARNES), luego carbohidratos (GRUPO1_CEREALES), finalmente calorías totales. Para cada macronutriente con déficit, ajusta comidas principales (almuerzo y cena) primero, luego comidas secundarias si el déficit es grande. Utiliza función _ajustar_comida_para_macronutriente que agrega o modifica alimentos en una comida específica para cubrir déficit.

Reducción de excesos: Si algún macronutriente excede 100%, se aplica función _reducir_excesos_dia que reduce proporcionalmente cantidades de alimentos que contribuyen al exceso. Calcula factor de reducción que limita el macronutriente excedente a 100%, luego aplica factor a todas las cantidades manteniendo proporciones.

Validación post-optimización: Después de optimizar, se valida que ningún día exceda 100% en ningún macronutriente. Si hay excesos, se aplica reducción automática. Se verifica que variedad se mantenga (no se repitan alimentos excesivamente). Se calcula cumplimiento final y se incluye en estadísticas de optimización retornadas al frontend.

## 1.1.4.7. Integración de modelos ML en tiempo de ejecución

El sistema carga modelos ML bajo demanda cuando se necesita realizar predicciones, optimizando uso de memoria.

Carga de modelos: Los modelos se cargan mediante funciones _cargar_modelo_respuesta_glucemica, _cargar_modelo_seleccion_alimentos y _cargar_modelo_optimizacion_combinaciones que verifican si el modelo ya está cargado antes de intentar cargarlo nuevamente. Utilizan rutas relativas desde la raíz del proyecto (ApartadoInteligente/ModeloML/) para garantizar portabilidad. Si un modelo no está disponible, el sistema continúa funcionando con reglas basadas en conocimiento, registrando advertencias en logs.

Predicción de control glucémico: El modelo de respuesta glucémica se utiliza para predecir probabilidad de mal control mediante función predecir_control_glucemico_ml que prepara features del perfil del paciente (edad, sexo, IMC, HbA1c, glucosa, etc.) y realiza predicción. La probabilidad se combina con reglas clínicas mediante función _determinar_control_glucemico que ajusta probabilidad si hay valores clínicos elevados (HbA1c mayor o igual a 7.0 aumenta probabilidad a mínimo 0.7). El resultado se utiliza para ajustar metas nutricionales y distribución calórica.

Selección inteligente de alimentos: El modelo de selección de alimentos se utiliza para calcular score de idoneidad mediante función calcular_score_idoneidad_alimento que prepara features del paciente y del alimento y realiza predicción. Los alimentos se ordenan por score descendente antes de la selección, priorizando aquellos con mayor idoneidad para el perfil del paciente. El score se combina con filtros de seguridad (IG, alergias) para generar lista final de recomendaciones.

Optimización de combinaciones: El modelo de optimización de combinaciones se utiliza para evaluar calidad de combinaciones de alimentos mediante función calcular_score_combinacion que prepara features de la combinación completa y realiza predicción. Se utiliza durante la optimización para validar que combinaciones sugeridas tengan score mayor a umbral mínimo (0.6 por defecto). Si una combinación tiene score bajo, se busca alternativa con mejor score.

## 1.1.4.8. Endpoint de configuración inteligente

Se implementó endpoint /api/recomendacion/configuracion/<paciente_id> que proporciona configuración recomendada con ajuste ML.

Funcionalidad: El endpoint obtiene perfil del paciente mediante obtener_perfil_paciente. Calcula configuración base (calorías y macronutrientes) mediante fórmulas clínicas estándar (Harris-Benedict para TMB, factores de actividad, ajustes por IMC y control glucémico). Aplica ajuste ML mediante calcular_metas_nutricionales que internamente utiliza modelos ML para ajustar configuración base. Retorna configuración base (antes del ajuste ML) y configuración final (después del ajuste ML) para permitir comparación en el frontend.

Ajustes según control glucémico: Si probabilidad de mal control mayor a 0.6, se reduce IG máximo a 55 y repeticiones máximas a 2. Si probabilidad entre 0.4 y 0.6, se establece IG máximo a 65 y repeticiones máximas a 3. Si probabilidad menor a 0.4, se establece IG máximo a 70 y repeticiones máximas a 3.

Respuesta del endpoint: Incluye configuración_base con valores calculados por reglas clínicas. Incluye configuracion_final con valores ajustados por ML. Incluye metas_nutricionales con valores finales en gramos y porcentajes. Incluye objeto ml con probabilidad_mal_control (cruda del modelo), probabilidad_ajustada (combinada con reglas) y control_glucemico (clasificación: BUENO, MODERADO, MALO).

## 1.1.4.9. Mejoras en interfaz de usuario

Búsqueda de pacientes mejorada: Se implementó búsqueda desde primer carácter mediante modificación de event listener en input de búsqueda que dispara búsqueda con query.length mayor o igual a 1 (anteriormente requería 2 caracteres). Se mejoró ordenamiento de resultados mediante SQL que prioriza coincidencias exactas o que empiezan con la query, luego coincidencias parciales. Se aumentó límite de resultados a 50 para mostrar más opciones.

Visualización de cumplimiento: Se implementó cálculo de cumplimiento en frontend mediante función JavaScript cumpleObjetivos que verifica que todos los macronutrientes (Kcal, CHO, PRO, FAT) estén entre 83% y 100%. Se removió texto Cumple y No cumple de la interfaz, manteniendo solo porcentajes y colores (verde para cumplimiento, amarillo para advertencia, rojo para no cumplimiento). Se corrigió cálculo removiendo Math.floor que causaba redondeo incorrecto, utilizando comparación directa con Number().

Formato de visualización de planes: Se implementaron tres formatos de visualización mediante JavaScript que transforma estructura de datos del plan en diferentes representaciones HTML. Formato Lista muestra alimentos en lista vertical con información nutricional expandible. Formato Horario muestra tabla con horas y alimentos correspondientes, útil para seguimiento temporal. Formato Tabla Semanal muestra grid con días como columnas y comidas como filas, útil para visión general de la semana.

Paginación de semanas: Se implementó paginación para planes de múltiples semanas mediante JavaScript que divide días del plan en grupos de 7 (semanas). Se calcula número total de páginas mediante Math.ceil(dias / 7). Se implementan botones Anterior y Siguiente que actualizan índice de semana actual y recalculan rango de días a mostrar. Se muestra indicador de página actual y total (ej: Semana 1 de 4).

