# 1.1.4. Iteración 4: Evaluación e Integración del Modelo (CRISP-DM) + Sprint 4 (SCRUM)

## 1.1.4.1. Propósito y alcance del sprint

El objetivo de este cuarto sprint fue integrar completamente los modelos de Machine Learning en la plataforma web, implementar el optimizador de planes para mejorar precisión en el cumplimiento de objetivos nutricionales, desarrollar la interfaz de usuario completa para generación y visualización de planes, implementar la persistencia de planes en base de datos, y establecer el sistema de aprendizaje continuo que permite al sistema mejorar con el tiempo basándose en resultados reales.

Se definió un alcance centrado en la integración end-to-end del sistema: desde la interfaz de usuario hasta la base de datos, pasando por los modelos ML y el motor de recomendación. Esto incluyó la implementación de endpoints RESTful para comunicación frontend-backend, la carga y utilización de modelos ML en tiempo de ejecución, la implementación del módulo OptimizadorPlan que ajusta iterativamente los planes para cumplir objetivos nutricionales con mayor precisión, el desarrollo de interfaces de usuario intuitivas para configuración y visualización de planes, la persistencia completa de planes en base de datos con estados (borrador/publicado), y la implementación de hooks de aprendizaje continuo que registran baselines y resultados para mejorar futuras recomendaciones.

El foco técnico se centró en garantizar que el sistema funcione de manera robusta y confiable en un entorno de producción, con manejo adecuado de errores, validaciones exhaustivas, integración fluida entre componentes del sistema (frontend, backend, modelos ML, base de datos), y capacidad de aprendizaje continuo sin afectar el funcionamiento actual del sistema.

## 1.1.4.2. Pruebas de caja negra

Durante este sprint se implementaron componentes críticos del sistema que requieren lógica de control compleja: el optimizador de planes que ajusta iterativamente las cantidades de alimentos, el sistema de carga de modelos ML que debe funcionar de manera robusta incluso cuando los modelos no están disponibles, y la función de determinación de control glucémico que combina predicciones ML con reglas clínicas. Estas funcionalidades son fundamentales para que el sistema genere planes nutricionales precisos y personalizados.

Las pruebas de caja negra se realizaron mediante revisión del código fuente para verificar que las estructuras de control (condicionales, bucles) estén correctamente implementadas y manejen adecuadamente todos los casos posibles, incluyendo casos límite y errores. Estas pruebas validan la lógica interna del código asegurando que el sistema funcione de manera confiable y robusta.

### Prueba PCN01: Verificación de estructuras condicionales en OptimizadorPlan

**Contexto en el sprint:** Durante este sprint se implementó el módulo OptimizadorPlan que es responsable de ajustar iterativamente los planes nutricionales generados para que cumplan con precisión los objetivos nutricionales establecidos. Este componente es crítico porque garantiza que los planes generados sean nutricionalmente adecuados y cumplan con los porcentajes de macronutrientes requeridos (83%-100% para cada macronutriente y promedio ≥ 90%).

**Qué demuestra esta prueba:** Esta prueba demuestra que el optimizador implementa correctamente la lógica iterativa de optimización, verificando que el bucle de optimización itera correctamente hasta el máximo de iteraciones permitidas, que las estructuras condicionales identifican adecuadamente los días que ya cumplen objetivos (permitiendo saltarlos para optimizar rendimiento), que detecta correctamente cuando algún macronutriente excede el 100% y aplica reducción proporcional, y que se detiene cuando no hay mejoras en una iteración completa (evitando bucles infinitos). Esto garantiza que el optimizador funcione de manera eficiente y produzca planes que cumplan los objetivos nutricionales.

**Requisito:**
- Módulo / Área Funcional / Subproceso: Optimización de planes nutricionales
- Tipo de requisito: Funcional
- Código del requisito: RF04
- Descripción del requisito: El sistema debe optimizar planes nutricionales para cumplir objetivos nutricionales con precisión. El optimizador debe iterar hasta máximo 20 veces o hasta que todos los días cumplan objetivos (promedio mayor o igual a 90% y todos los macronutrientes entre 83% y 100%).

**Caso de prueba:**
- Código de prueba: PCN01
- Caso de prueba: Verificación de estructuras condicionales en bucle de optimización
- Descripción de la prueba: Revisar si las estructuras condicionales dentro del bucle for de optimización están debidamente implementadas y muestren los resultados esperados. Verificar que el bucle itera correctamente hasta máximo 20 iteraciones y se detiene cuando no hay mejoras.
- Funcionalidad / Característica a evaluar: Bucle for con máximo de iteraciones y condicionales para verificar cumplimiento y excesos funcionan correctamente
- Datos de entrada / Acciones de entrada: Código fuente - Core/optimizador_plan.py, función optimizar_plan, líneas 215-313
- Resultado esperado: Bucle itera correctamente, condicionales verifican cumplimiento (if cumplimiento.cumple_objetivos), verifican excesos (if exceso_significativo), y se detiene cuando mejoras_en_iteracion == 0

**Requerimientos de ambiente de pruebas:**
- Equipo: Computadora con Python 3.8+ instalado
- Código fuente: Core/optimizador_plan.py
- Conexión a internet: No requerida

**Condiciones / Restricciones:**
- Contar con acceso al código fuente
- Tener Python instalado para ejecutar pruebas unitarias

**Pasos de la prueba:**
1. Abrir el archivo Core/optimizador_plan.py en editor de código
2. Ubicar la función optimizar_plan (línea 140)
3. Revisar el bucle for iteracion in range(self.max_iteraciones) (línea 215)
4. Verificar condicional if cumplimiento.cumple_objetivos (línea 227)
5. Verificar condicional if exceso_significativo (línea 240)
6. Verificar condicional if mejoras_en_iteracion == 0 (línea 312)
7. Verificar que todas las estructuras condicionales tienen bloques else o continue apropiados

**Resultado obtenido:** Todas las estructuras condicionales están correctamente implementadas y funcionan según lo esperado. El bucle itera correctamente hasta máximo 20 iteraciones, las condicionales verifican cumplimiento y excesos adecuadamente, y el bucle se detiene cuando no hay mejoras.

### Prueba PCN02: Verificación de estructuras condicionales en carga de modelos ML

**Contexto en el sprint:** Una de las tareas principales de este sprint fue integrar los tres modelos ML especializados en la plataforma web. Los modelos se cargan bajo demanda para optimizar el uso de memoria y el tiempo de inicio del servidor. Sin embargo, es crítico que el sistema funcione de manera robusta incluso cuando los modelos no están disponibles (por ejemplo, en entornos donde no se han desplegado los archivos .pkl o cuando hay problemas con las dependencias).

**Qué demuestra esta prueba:** Esta prueba demuestra que el sistema implementa correctamente la estrategia de carga lazy (bajo demanda) de modelos ML, verificando que se previenen recargas innecesarias de modelos ya cargados, que el sistema detecta correctamente cuando las dependencias ML no están disponibles y hace fallback a reglas basadas en conocimiento, que maneja adecuadamente la ausencia de archivos de modelos, y que captura y maneja errores de carga sin interrumpir el funcionamiento del sistema. Esto garantiza que el sistema sea robusto y funcione incluso en escenarios donde los modelos ML no están disponibles, lo cual es esencial para la confiabilidad del sistema en producción.

**Requisito:**
- Módulo / Área Funcional / Subproceso: Integración de modelos ML
- Tipo de requisito: Funcional
- Código del requisito: RF05
- Descripción del requisito: El sistema debe cargar modelos ML bajo demanda cuando se necesita realizar predicciones. Si un modelo no está disponible, el sistema debe continuar funcionando con reglas basadas en conocimiento, registrando advertencias en logs.

**Caso de prueba:**
- Código de prueba: PCN02
- Caso de prueba: Verificación de estructuras condicionales en carga de modelos ML
- Descripción de la prueba: Revisar si las estructuras condicionales en las funciones de carga de modelos ML están debidamente implementadas. Verificar que se verifica si el modelo ya está cargado, si las dependencias están disponibles, si los archivos existen, y se manejan errores correctamente.
- Funcionalidad / Característica a evaluar: Estructuras condicionales para verificación de carga de modelos funcionan correctamente
- Datos de entrada / Acciones de entrada: Código fuente - Core/motor_recomendacion.py, funciones _cargar_modelo_respuesta_glucemica, _cargar_modelo_seleccion_alimentos, _cargar_modelo_optimizacion_combinaciones
- Resultado esperado: Condicionales verifican correctamente si modelo está cargado (if self._modelo_ml is not None), si dependencias están disponibles (if not ML_AVAILABLE), si archivos existen (if not modelo_path.exists()), y manejan errores con try-except

**Requerimientos de ambiente de pruebas:**
- Equipo: Computadora con Python 3.8+ instalado
- Código fuente: Core/motor_recomendacion.py
- Archivos de modelos: ApartadoInteligente/ModeloML/*.pkl (opcional para prueba)
- Conexión a internet: No requerida

**Condiciones / Restricciones:**
- Contar con acceso al código fuente
- Tener Python instalado

**Pasos de la prueba:**
1. Abrir el archivo Core/motor_recomendacion.py en editor de código
2. Ubicar la función _cargar_modelo_respuesta_glucemica (línea 196)
3. Verificar condicional if self._modelo_respuesta_glucemica is not None (línea 198)
4. Verificar condicional if not ML_AVAILABLE (línea 202)
5. Verificar condicional if not modelo_path.exists() (línea 214)
6. Verificar estructura try-except para manejo de errores (línea 208)
7. Repetir pasos 2-6 para _cargar_modelo_seleccion_alimentos y _cargar_modelo_optimizacion_combinaciones

**Resultado obtenido:** Todas las estructuras condicionales están correctamente implementadas y el sistema maneja adecuadamente casos de error. Los modelos se cargan bajo demanda, se previenen recargas innecesarias, y el sistema continúa funcionando con reglas basadas en conocimiento cuando los modelos no están disponibles.

### Prueba PCN03: Verificación de estructuras condicionales anidadas en _determinar_control_glucemico

**Contexto en el sprint:** Durante este sprint se implementó el endpoint de configuración inteligente que utiliza el modelo ML de control glucémico para ajustar automáticamente los parámetros del plan (IG máximo, repeticiones máximas) según el nivel de control glucémico del paciente. La función _determinar_control_glucemico es fundamental porque combina las predicciones del modelo ML con reglas clínicas basadas en valores de HbA1c y glucosa en ayunas, priorizando diferentes fuentes de información según su disponibilidad.

**Qué demuestra esta prueba:** Esta prueba demuestra que el sistema implementa correctamente la lógica de priorización y clasificación de control glucémico, verificando que se prioriza correctamente la probabilidad_ajustada (combinada con reglas clínicas) sobre la probabilidad_ml (cruda del modelo), que se utiliza valores clínicos (HbA1c, glucosa) como fallback cuando las predicciones ML no están disponibles, que clasifica correctamente según los umbrales establecidos (0.6 para MALO, 0.4 para MODERADO), y que todas las rutas de código retornan un valor válido. Esto garantiza que el sistema siempre pueda determinar el control glucémico del paciente y ajustar la configuración del plan de manera apropiada, incluso cuando el modelo ML no está disponible o cuando hay inconsistencias en los datos.

**Requisito:**
- Módulo / Área Funcional / Subproceso: Clasificación de control glucémico
- Tipo de requisito: Funcional
- Código del requisito: RF07
- Descripción del requisito: El sistema debe determinar el control glucémico del paciente basado en probabilidades ML o valores clínicos. Prioriza probabilidad_ajustada > probabilidad_ml > valores clínicos. Clasifica como BUENO, MODERADO o MALO según umbrales.

**Caso de prueba:**
- Código de prueba: PCN03
- Caso de prueba: Verificación de estructuras condicionales anidadas en determinación de control glucémico
- Descripción de la prueba: Revisar si las estructuras condicionales anidadas en la función _determinar_control_glucemico están debidamente implementadas. Verificar que se prioriza probabilidad_ajustada sobre probabilidad_ml, y valores clínicos como fallback. Verificar clasificación según umbrales (0.6 para MALO, 0.4 para MODERADO).
- Funcionalidad / Característica a evaluar: Estructuras condicionales anidadas para priorización y clasificación funcionan correctamente
- Datos de entrada / Acciones de entrada: Código fuente - main.py, función _determinar_control_glucemico, líneas 4783-4815
- Resultado esperado: Condicionales verifican correctamente prioridad (if prob_final is None), clasificación según umbrales (if prob_final > 0.6, elif prob_final > 0.4), y fallback a valores clínicos (if perfil.hba1c >= 7.0, if perfil.glucosa_ayunas >= 140)

**Requerimientos de ambiente de pruebas:**
- Equipo: Computadora con Python 3.8+ instalado
- Código fuente: main.py
- Conexión a internet: No requerida

**Condiciones / Restricciones:**
- Contar con acceso al código fuente
- Tener Python instalado

**Pasos de la prueba:**
1. Abrir el archivo main.py en editor de código
2. Ubicar la función _determinar_control_glucemico (línea 4783)
3. Verificar condicional de priorización: if prob_final is None (línea 4792)
4. Verificar condicionales de clasificación ML:
   - if prob_final > 0.6: return 'MALO' (línea 4797)
   - elif prob_final > 0.4: return 'MODERADO' (línea 4799)
   - else: return 'BUENO' (línea 4801)
5. Verificar condicionales de fallback clínico:
   - if perfil.hba1c and perfil.hba1c >= 7.0: return 'MALO' (línea 4806)
   - if perfil.glucosa_ayunas and perfil.glucosa_ayunas >= 140: return 'MALO' (línea 4808)
   - if perfil.hba1c and perfil.hba1c >= 6.5: return 'MODERADO' (línea 4812)
6. Verificar que todas las rutas de código retornan un valor válido

**Resultado obtenido:** Las estructuras condicionales anidadas implementan correctamente la priorización y clasificación de control glucémico. Se prioriza probabilidad_ajustada sobre probabilidad_ml, y valores clínicos como fallback. La clasificación según umbrales funciona correctamente.

### Resumen de resultados de pruebas de caja negra

Todas las 3 pruebas de caja negra fueron ejecutadas y validadas mediante revisión de código. Los resultados confirman que las estructuras condicionales y bucles están correctamente implementadas en todos los componentes críticos del sistema. Las pruebas validaron la lógica interna de: optimización iterativa de planes, carga bajo demanda de modelos ML, y determinación de control glucémico. Todas las estructuras de control funcionan según los requisitos establecidos y manejan adecuadamente casos límite y errores.

## 1.1.4.3. Pruebas de caja blanca

Durante este sprint se implementaron los endpoints RESTful que permiten la comunicación entre el frontend y el backend, integrando los modelos ML y el motor de recomendación. Estos endpoints son la interfaz principal que utiliza la aplicación web para generar planes nutricionales, obtener configuraciones inteligentes ajustadas por ML, y persistir planes en la base de datos. La correcta funcionalidad de estos endpoints es esencial para que el sistema funcione desde la perspectiva del usuario final.

Las pruebas de caja blanca se realizaron mediante peticiones HTTP usando Postman o DevTools del navegador para verificar el comportamiento externo del sistema sin conocer la implementación interna. Estas pruebas validan que los endpoints respondan correctamente a las peticiones, que los datos se envíen y reciban en el formato esperado, y que el sistema funcione correctamente desde la perspectiva del usuario final. Las pruebas se enfocan en validar la integración completa del sistema: desde la generación de planes con filtros y exclusiones, hasta la configuración inteligente con ajuste ML, y la persistencia de datos en la base de datos.

### Prueba PCB01: Generación de plan nutricional con exclusión de grupos alimentarios

**Contexto en el sprint:** Durante este sprint se implementó la funcionalidad de exclusión de grupos alimentarios completos durante la generación del plan, permitiendo a los nutricionistas personalizar los planes según las necesidades específicas del paciente (por ejemplo, excluir azúcares para pacientes con diabetes mal controlada, o excluir lácteos para pacientes con intolerancia a la lactosa). Esta funcionalidad es crítica para la personalización de los planes nutricionales.

**Qué demuestra esta prueba:** Esta prueba demuestra que el endpoint de generación de planes respeta correctamente las exclusiones de grupos alimentarios especificadas por el usuario, verificando que cuando se envía una petición con grupos_excluidos en el body, el sistema retorna un plan completo que no contiene ningún alimento del grupo excluido, mientras que sí incluye alimentos de otros grupos. Esto garantiza que la funcionalidad de exclusión funcione correctamente y que los planes generados sean adecuados para pacientes con restricciones alimentarias específicas. La prueba valida la integración completa entre el frontend (que envía las exclusiones), el backend (que procesa las exclusiones), y el motor de recomendación (que genera el plan respetando las exclusiones).

**Requisito:**
- Módulo / Área Funcional / Subproceso: Generación de planes nutricionales
- Tipo de requisito: Funcional
- Código del requisito: RF09
- Descripción del requisito: El sistema debe permitir excluir grupos alimentarios completos durante la generación del plan. Los alimentos del grupo excluido no deben aparecer en el plan generado.

**Caso de prueba:**
- Código de prueba: PCB01
- Caso de prueba: Verificación de exclusión de grupos alimentarios mediante petición HTTP
- Descripción de la prueba: Verificar mediante Postman o DevTools del navegador que al enviar una petición POST a /api/recomendacion/generar con grupos_excluidos en el body, el sistema retorna un plan sin alimentos del grupo excluido. Verificar en la respuesta JSON que ningún alimento tiene grupo igual al excluido.
- Funcionalidad / Característica a evaluar: Endpoint de generación de planes respeta exclusiones de grupos alimentarios
- Datos de entrada / Acciones de entrada:
  - Petición POST a /api/recomendacion/generar
  - Body JSON: { "paciente_id": 1, "configuracion": { "dias_plan": 7, "kcal_obj": 2000 }, "ingredientes": { "grupos_excluidos": ["GRUPO6_AZUCARES"] } }
  - Headers: Content-Type: application/json, Cookie con sesión activa
- Resultado esperado:
  - Status code 200 OK
  - Respuesta JSON con plan_completo
  - Ningún alimento en el plan tiene grupo igual a "GRUPO6_AZUCARES"
  - El plan contiene alimentos de otros grupos (GRUPO1_CEREALES, GRUPO2_VERDURAS, etc.)

**Requerimientos de ambiente de pruebas:**
- Equipo: Computadora con navegador web (Chrome, Firefox, Edge) o Postman
- Sistema: Aplicación web ejecutándose en localhost o servidor
- Usuario: Sesión activa de nutricionista o administrador
- Base de datos: Paciente de prueba con datos clínicos y antropométricos registrados
- Conexión a internet: No requerida (si el sistema está en localhost)

**Condiciones / Restricciones:**
- Tener sesión de usuario activa (obtener cookie de sesión mediante login)
- Tener al menos un paciente registrado con ID conocido
- El sistema debe estar funcionando correctamente

**Pasos de la prueba:**
1. Abrir Postman o DevTools del navegador (F12)
2. Realizar login en la aplicación para obtener cookie de sesión
3. En Postman: Crear nueva petición POST
   - URL: http://localhost:5000/api/recomendacion/generar
   - Método: POST
   - Headers: Content-Type: application/json, Cookie: [cookie de sesión]
   - Body (raw JSON) con grupos_excluidos: ["GRUPO6_AZUCARES"]
4. Enviar la petición
5. Verificar respuesta:
   - Status code debe ser 200
   - Response body debe contener plan_completo
6. Inspeccionar el JSON de respuesta y buscar todos los alimentos
7. Verificar que ningún alimento tiene grupo igual a "GRUPO6_AZUCARES"

**Evidencia requerida (capturas de pantalla):**
1. Postman o DevTools mostrando la petición POST con URL completa, Headers (Content-Type, Cookie), y Body JSON con grupos_excluidos: ["GRUPO6_AZUCARES"]
2. Postman o DevTools mostrando la respuesta con Status code 200 y Response body JSON (puede ser parcial si es muy largo)
3. Detalle del JSON de respuesta mostrando un día del plan (ej: dia_1) con alimentos, verificando que ningún alimento tiene grupo "GRUPO6_AZUCARES"
4. Búsqueda en el JSON de respuesta de la palabra "GRUPO6_AZUCARES" mostrando que no aparece (0 resultados)

**Resultado obtenido:** El endpoint respeta correctamente las exclusiones de grupos alimentarios y retorna planes sin alimentos del grupo excluido. Ningún alimento del grupo excluido aparece en el plan generado.

### Prueba PCB02: Configuración inteligente con ajuste ML según control glucémico

**Contexto en el sprint:** Una de las funcionalidades principales implementadas en este sprint fue el endpoint de configuración inteligente que utiliza el modelo ML de control glucémico para ajustar automáticamente los parámetros del plan nutricional según el nivel de control glucémico del paciente. Esta funcionalidad permite que el sistema personalice automáticamente el plan sin que el nutricionista tenga que ajustar manualmente los parámetros, mejorando la eficiencia y la precisión de las recomendaciones.

**Qué demuestra esta prueba:** Esta prueba demuestra que el endpoint de configuración inteligente integra correctamente el modelo ML de control glucémico y ajusta los parámetros del plan según la clasificación del paciente, verificando que para pacientes con control glucémico MALO (probabilidad > 0.6) se ajusta el IG máximo a 55 y las repeticiones máximas a 2, para pacientes con control MODERADO (probabilidad entre 0.4 y 0.6) se ajusta el IG máximo a 65 y las repeticiones máximas a 3, y para pacientes con control BUENO (probabilidad < 0.4) se ajusta el IG máximo a 70 y las repeticiones máximas a 3. La prueba también valida que el endpoint retorna tanto la configuración base (calculada por reglas clínicas) como la configuración final (ajustada por ML), permitiendo al nutricionista comparar y entender los ajustes realizados. Esto garantiza que el sistema personalice correctamente los planes según el perfil de cada paciente.

**Requisito:**
- Módulo / Área Funcional / Subproceso: Configuración de planes nutricionales
- Tipo de requisito: Funcional
- Código del requisito: RF10
- Descripción del requisito: El sistema debe proporcionar configuración recomendada con ajuste ML mediante endpoint /api/recomendacion/configuracion/<paciente_id>. Debe ajustar IG máximo y repeticiones máximas según probabilidad de mal control: > 0.6 (IG 55, rep 2), 0.4-0.6 (IG 65, rep 3), < 0.4 (IG 70, rep 3). Debe mostrar clasificación de control glucémico (BUENO, MODERADO, MALO).

**Caso de prueba:**
- Código de prueba: PCB02
- Caso de prueba: Verificación de configuración inteligente mediante petición HTTP GET
- Descripción de la prueba: Verificar mediante Postman o DevTools que al realizar petición GET a /api/recomendacion/configuracion/<paciente_id>, el sistema retorna configuración base, configuración final ajustada por ML, y clasificación de control glucémico. Verificar que los valores de IG máximo y repeticiones máximas se ajustan según la clasificación.
- Funcionalidad / Característica a evaluar: Endpoint de configuración retorna valores ajustados por ML según control glucémico
- Datos de entrada / Acciones de entrada:
  - Petición GET a /api/recomendacion/configuracion/1 (paciente con control MALO)
  - Petición GET a /api/recomendacion/configuracion/2 (paciente con control MODERADO)
  - Petición GET a /api/recomendacion/configuracion/3 (paciente con control BUENO)
  - Headers: Cookie con sesión activa
- Resultado esperado:
  - Status code 200 OK para cada petición
  - Respuesta JSON con estructura: configuracion_base, configuracion_final, ml (con probabilidad_mal_control, probabilidad_ajustada, control_glucemico)
  - Para paciente con control MALO: configuracion_final.ig_max = 55, repeticiones_max = 2
  - Para paciente con control MODERADO: configuracion_final.ig_max = 65, repeticiones_max = 3
  - Para paciente con control BUENO: configuracion_final.ig_max = 70, repeticiones_max = 3

**Requerimientos de ambiente de pruebas:**
- Equipo: Computadora con navegador web (Chrome, Firefox, Edge) o Postman
- Sistema: Aplicación web ejecutándose en localhost o servidor
- Usuario: Sesión activa de nutricionista o administrador
- Base de datos:
  - Paciente 1: Con HbA1c >= 7.0 o glucosa >= 140 (control MALO)
  - Paciente 2: Con HbA1c entre 6.5 y 6.9 o glucosa entre 126 y 139 (control MODERADO)
  - Paciente 3: Con HbA1c < 6.5 y glucosa < 126 (control BUENO)
- Conexión a internet: No requerida (si el sistema está en localhost)

**Condiciones / Restricciones:**
- Tener sesión de usuario activa (obtener cookie de sesión mediante login)
- Tener al menos 3 pacientes registrados con diferentes niveles de control glucémico
- Conocer los IDs de los pacientes de prueba

**Pasos de la prueba:**
1. Abrir Postman o DevTools del navegador (F12)
2. Realizar login en la aplicación para obtener cookie de sesión
3. En Postman: Crear nueva petición GET
   - URL: http://localhost:5000/api/recomendacion/configuracion/1
   - Método: GET
   - Headers: Cookie: [cookie de sesión]
4. Enviar la petición para Paciente 1 (control MALO)
5. Verificar respuesta:
   - Status code debe ser 200
   - Response body debe contener configuracion_base, configuracion_final y ml
   - Verificar que ml.control_glucemico = "MALO"
   - Verificar que configuracion_final.ig_max = 55
   - Verificar que configuracion_final.repeticiones_max = 2
6. Repetir pasos 3-5 para Paciente 2 (control MODERADO) cambiando URL a /configuracion/2
7. Repetir pasos 3-5 para Paciente 3 (control BUENO) cambiando URL a /configuracion/3

**Evidencia requerida (capturas de pantalla):**
1. Postman o DevTools mostrando petición GET a /api/recomendacion/configuracion/1 con URL completa, Headers (Cookie), y Response status 200
2. Response body JSON para Paciente 1 mostrando configuracion_base.ig_max (valor base), configuracion_final.ig_max = 55, configuracion_final.repeticiones_max = 2, ml.control_glucemico = "MALO"
3. Response body JSON para Paciente 2 mostrando configuracion_final.ig_max = 65, configuracion_final.repeticiones_max = 3, ml.control_glucemico = "MODERADO"
4. Response body JSON para Paciente 3 mostrando configuracion_final.ig_max = 70, configuracion_final.repeticiones_max = 3, ml.control_glucemico = "BUENO"

**Resultado obtenido:** El endpoint retorna correctamente configuración ajustada por ML y clasificación de control glucémico. Los valores de IG máximo y repeticiones máximas se ajustan correctamente según la clasificación de control glucémico del paciente.

### Prueba PCB03: Guardado de plan nutricional en base de datos

**Contexto en el sprint:** Durante este sprint se implementó la funcionalidad de persistencia de planes nutricionales en la base de datos, permitiendo a los nutricionistas guardar los planes generados como borrador o publicarlos para que estén disponibles para los pacientes. Esta funcionalidad es esencial para que el sistema pueda almacenar y recuperar planes, y es el punto de entrada para el sistema de aprendizaje continuo que registra baselines cuando se guardan planes.

**Qué demuestra esta prueba:** Esta prueba demuestra que el endpoint de guardado de planes funciona correctamente y persiste los datos en la base de datos, verificando que cuando se envía una petición POST con un plan completo, el sistema guarda correctamente todos los datos del plan (estructura completa del plan, configuración, ingredientes utilizados) en la base de datos, retorna el ID del plan guardado y la URL de detalle, y permite recuperar el plan guardado mediante una petición GET a la URL de detalle. Esto garantiza que los planes generados puedan ser almacenados y recuperados correctamente, permitiendo a los nutricionistas trabajar con planes de manera persistente y habilitando el seguimiento y aprendizaje continuo del sistema.

**Requisito:**
- Módulo / Área Funcional / Subproceso: Persistencia de planes nutricionales
- Tipo de requisito: Funcional
- Código del requisito: RF11
- Descripción del requisito: El sistema debe permitir guardar planes nutricionales generados en la base de datos mediante endpoint /api/planes con método POST. El plan debe guardarse con estado "borrador" o "publicado" y debe retornar el ID del plan guardado y URL de detalle.

**Caso de prueba:**
- Código de prueba: PCB03
- Caso de prueba: Verificación de guardado de plan mediante petición HTTP POST
- Descripción de la prueba: Verificar mediante Postman o DevTools que al enviar una petición POST a /api/planes con un plan completo en el body, el sistema guarda el plan en la base de datos y retorna ID del plan y URL de detalle. Verificar que el plan se puede recuperar mediante GET /planes/<plan_id>.
- Funcionalidad / Característica a evaluar: Endpoint de guardado de planes funciona correctamente y persiste datos en base de datos
- Datos de entrada / Acciones de entrada:
  - Petición POST a /api/planes
  - Body JSON: { "paciente_id": 1, "estado": "borrador", "plan": { estructura completa del plan }, "configuracion": { parámetros de configuración }, "ingredientes": { filtros aplicados } }
  - Headers: Content-Type: application/json, Cookie con sesión activa
- Resultado esperado:
  - Status code 200 OK
  - Respuesta JSON: { "ok": true, "id": plan_id, "detalle_url": "/planes/<plan_id>" }
  - El plan se guarda en la base de datos
  - Se puede recuperar el plan mediante GET /planes/<plan_id>

**Requerimientos de ambiente de pruebas:**
- Equipo: Computadora con navegador web (Chrome, Firefox, Edge) o Postman
- Sistema: Aplicación web ejecutándose en localhost o servidor
- Usuario: Sesión activa de nutricionista o administrador
- Base de datos: PostgreSQL con tablas plan, plan_detalle, plan_alimento
- Conexión a internet: No requerida (si el sistema está en localhost)

**Condiciones / Restricciones:**
- Tener sesión de usuario activa (obtener cookie de sesión mediante login)
- Tener un plan nutricional generado (puede generarse previamente o incluirse en el body)
- El paciente_id debe existir en la base de datos

**Pasos de la prueba:**
1. Abrir Postman o DevTools del navegador (F12)
2. Realizar login en la aplicación para obtener cookie de sesión
3. Generar un plan nutricional previamente (o preparar estructura de plan en JSON)
4. En Postman: Crear nueva petición POST
   - URL: http://localhost:5000/api/planes
   - Método: POST
   - Headers: Content-Type: application/json, Cookie: [cookie de sesión]
   - Body (raw JSON) con estructura completa del plan
5. Enviar la petición
6. Verificar respuesta:
   - Status code debe ser 200
   - Response body debe contener ok: true, id: [número], detalle_url: "/planes/[id]"
7. Realizar petición GET a la URL retornada en detalle_url
8. Verificar que el plan se recupera correctamente con status 200

**Evidencia requerida (capturas de pantalla):**
1. Postman o DevTools mostrando la petición POST a /api/planes con URL completa, Headers (Content-Type, Cookie), y Body JSON (puede ser parcial si es muy largo, mostrar estructura principal)
2. Response de POST /api/planes mostrando Status code 200 y Response body: { "ok": true, "id": [número], "detalle_url": "/planes/[id]" }
3. Petición GET a /planes/[id] mostrando URL completa, Status code 200, y Response HTML o JSON con datos del plan guardado
4. Verificación en base de datos (si se tiene acceso) mostrando registro en tabla plan con el id retornado

**Resultado obtenido:** El endpoint guarda correctamente los planes en la base de datos y permite recuperarlos mediante la URL de detalle. El plan se persiste con el estado especificado (borrador o publicado) y se puede acceder mediante la URL retornada.

### Resumen de resultados de pruebas de caja blanca

Todas las 3 pruebas de caja blanca fueron ejecutadas y validadas mediante peticiones HTTP. Los resultados confirman que los endpoints funcionan correctamente y responden según lo esperado. Las pruebas validaron el comportamiento externo de: generación de planes con exclusiones, configuración inteligente con ajuste ML, y persistencia de planes en base de datos. Todas las peticiones HTTP retornan status codes correctos y datos en el formato esperado.

## 1.1.4.4. Arquitectura de integración del modelo ML en la plataforma web

### 1.1.4.4.1. Arquitectura general del sistema

El sistema implementa una arquitectura cliente-servidor con separación clara de responsabilidades entre frontend (interfaz de usuario), backend (lógica de negocio y API), modelos ML (predicciones y optimizaciones), y base de datos (persistencia). El frontend se comunica con el backend mediante peticiones HTTP RESTful, el backend utiliza los modelos ML para realizar predicciones y optimizaciones, y todos los datos se persisten en PostgreSQL.

**Capa de presentación (Frontend):** Implementada con HTML, CSS (Bootstrap), y JavaScript (jQuery, Select2). Incluye templates Jinja2 para renderizado dinámico. Las interfaces principales son: formulario de configuración de planes (`obtener_plan.html`), visualización de planes generados (tres formatos: Lista, Horario, Tabla Semanal), y vista de detalle de planes guardados (`plan_detalle.html`).

**Capa de aplicación (Backend):** Implementada con Flask (Python). Incluye endpoints RESTful para todas las operaciones: generación de planes, configuración inteligente, persistencia de planes, búsqueda de pacientes, gestión de ingredientes. El backend orquesta la ejecución de los modelos ML y el motor de recomendación.

**Capa de modelos ML:** Implementada con XGBoost y scikit-learn. Los modelos se cargan bajo demanda desde archivos `.pkl` almacenados en `ApartadoInteligente/ModeloML/`. Incluye tres modelos especializados: Predicción de Respuesta Glucémica, Selección Personalizada de Alimentos, y Optimización de Combinaciones.

**Capa de datos:** Implementada con PostgreSQL. Almacena todos los datos del sistema: pacientes, registros clínicos, antropometría, ingredientes, planes, y datos de aprendizaje continuo.

### 1.1.4.4.2. Flujo completo de generación de planes

El flujo completo de generación de planes integra todos los componentes del sistema desde la interacción del usuario hasta la persistencia en base de datos:

1. **Interacción inicial del usuario:** El nutricionista accede a `/admin/obtener-plan` y selecciona un paciente mediante búsqueda mejorada (desde primer carácter). El sistema carga automáticamente los datos del paciente (último registro clínico y antropométrico).

2. **Configuración inteligente (opcional):** El usuario puede hacer clic en "Recomendación inteligente" que dispara una petición GET a `/api/recomendacion/configuracion/<paciente_id>`. Este endpoint:
   - Obtiene el perfil completo del paciente desde la base de datos
   - Calcula configuración base usando fórmulas clínicas estándar (Harris-Benedict para TMB, factores de actividad)
   - Utiliza el modelo ML de control glucémico para predecir probabilidad de mal control
   - Ajusta la configuración según el control glucémico (IG máximo, repeticiones máximas)
   - Retorna configuración base y configuración final ajustada por ML

3. **Configuración manual del plan:** El usuario puede ajustar manualmente: fecha de inicio (limitada a hoy y hasta una semana desde hoy), duración del plan (1, 2 o 3 semanas mediante select), calorías objetivo, distribución de macronutrientes, IG máximo, repeticiones máximas, patrón de comidas (desayuno, almuerzo y cena siempre marcados y deshabilitados; media mañana y media tarde opcionales), y exclusión de grupos alimentarios (máximo 2 grupos).

4. **Generación del plan:** Al hacer clic en "Generar Plan", se dispara una petición POST a `/api/recomendacion/generar` con toda la configuración. Este endpoint:
   - Valida los datos recibidos
   - Crea una instancia de `MotorRecomendacion`
   - Llama a `generar_plan_semanal_completo` que internamente:
     - Obtiene el perfil completo del paciente desde la base de datos
     - Calcula metas nutricionales (usando ML si está disponible)
     - Obtiene ingredientes recomendados aplicando filtros (IG, alergias, exclusiones)
     - Utiliza el Modelo 2 (Selección Personalizada) para rankear alimentos por idoneidad
     - Genera el plan día por día, tiempo por tiempo
     - Utiliza el Modelo 1 (Respuesta Glucémica) para excluir alimentos con pico glucémico excesivo
     - Aplica sistema de variedad para evitar repeticiones excesivas
     - Ajusta cantidades según límites por grupo (evita cantidades extremas)
     - Aplica lógica de combinaciones válidas (especialmente para GRUPO1_CEREALES)
   - Optimiza el plan usando `OptimizadorPlan` que:
     - Calcula cumplimiento inicial de cada día
     - Itera hasta máximo 20 veces o hasta que todos los días cumplan objetivos
     - Utiliza el Modelo 3 (Optimización de Combinaciones) para validar calidad de combinaciones
     - Ajusta cantidades para cubrir déficits de macronutrientes
     - Reduce excesos si algún macronutriente excede 100%
   - Retorna el plan completo con estructura JSON

5. **Visualización del plan:** El frontend recibe el plan y lo renderiza en tres formatos:
   - **Formato Lista:** Muestra alimentos en lista vertical con información nutricional expandible por día y comida
   - **Formato Horario:** Muestra tabla con horas y alimentos correspondientes, útil para seguimiento temporal
   - **Formato Tabla Semanal:** Muestra grid con días como columnas y comidas como filas, con paginación para planes de múltiples semanas

6. **Persistencia del plan:** El usuario puede guardar el plan como borrador o publicarlo. Se dispara una petición POST a `/api/planes` que:
   - Valida los datos del plan
   - Extrae fechas de inicio y fin
   - Guarda el plan completo en formato JSON en la tabla `plan`
   - Guarda la configuración original (propuesta por el sistema) y la configuración ajustada
   - Guarda los ingredientes utilizados
   - Si el aprendizaje continuo está habilitado (`APRENDIZAJE_CONTINUO=true`), registra el baseline mediante `hook_plan_guardado` que:
     - Obtiene datos clínicos y antropométricos actuales del paciente
     - Calcula IMC
     - Registra baseline en la tabla `plan_resultado` con estado 'pendiente'
   - Retorna ID del plan guardado y URL de detalle

7. **Visualización de detalle:** El usuario puede acceder al detalle del plan mediante `/planes/<plan_id>`. Este endpoint:
   - Carga el plan desde la base de datos
   - Renderiza el template `plan_detalle.html` con información completa
   - Muestra alimentos por día y comida con cantidades y valores nutricionales
   - Muestra recomendaciones especiales del sistema
   - Si el aprendizaje continuo está habilitado, muestra estado del baseline y aprendizaje

### 1.1.4.4.3. Integración de modelos ML en endpoints

**Endpoint `/api/recomendacion/configuracion/<paciente_id>` (GET):**

Este endpoint integra el modelo ML de control glucémico para proporcionar configuración ajustada:

1. Obtiene el perfil del paciente mediante `obtener_perfil_paciente` que carga datos desde la base de datos
2. Calcula configuración base usando fórmulas clínicas estándar
3. Utiliza `MotorRecomendacion.calcular_metas_nutricionales` que internamente:
   - Llama a `predecir_control_glucemico_ml` que utiliza el modelo ML de control glucémico (legado) para predecir probabilidad de mal control
   - Combina la probabilidad ML con reglas clínicas mediante `_determinar_control_glucemico`
   - Ajusta las metas nutricionales según el control glucémico
4. Retorna configuración base, configuración final ajustada, y objeto `ml` con probabilidad y clasificación

**Endpoint `/api/recomendacion/generar` (POST):**

Este endpoint integra los tres modelos ML durante la generación del plan:

1. Crea instancia de `MotorRecomendacion` que carga los modelos ML bajo demanda
2. Durante `generar_plan_semanal_completo`:
   - **Modelo 1 (Respuesta Glucémica):** Se utiliza en `_sugerir_*_variado` mediante `predecir_respuesta_glucemica` para excluir alimentos con pico glucémico predicho mayor a 180 mg/dL
   - **Modelo 2 (Selección Personalizada):** Se utiliza en `obtener_ingredientes_recomendados` mediante `calcular_score_idoneidad_alimento` para rankear alimentos por idoneidad antes de la selección
   - **Modelo 3 (Optimización de Combinaciones):** Se utiliza en `OptimizadorPlan` mediante `evaluar_combinacion_alimentos` para validar calidad de combinaciones durante la optimización
3. Retorna plan completo con todas las predicciones y optimizaciones aplicadas

**Endpoint `/api/planes` (POST):**

Este endpoint integra el sistema de aprendizaje continuo:

1. Guarda el plan en la base de datos
2. Si `APRENDIZAJE_CONTINUO=true`, llama a `hook_plan_guardado` que:
   - Obtiene datos clínicos y antropométricos actuales
   - Registra baseline en `plan_resultado` con estado 'pendiente'
   - Esto permite seguimiento futuro y aprendizaje del sistema

### 1.1.4.4.4. Carga y gestión de modelos ML

Los modelos ML se cargan bajo demanda para optimizar uso de memoria y tiempo de inicio del servidor:

**Estrategia de carga lazy (bajo demanda):** Los modelos se cargan solo cuando se necesita realizar una predicción. Esto se implementa mediante verificaciones `if self._modelo_* is not None` antes de cargar, evitando recargas innecesarias.

**Rutas relativas:** Los modelos se cargan desde `ApartadoInteligente/ModeloML/` usando rutas relativas desde la raíz del proyecto (`Path(__file__).parent.parent`), garantizando portabilidad entre entornos (local, producción en Render).

**Manejo de errores robusto:** Si un modelo no está disponible (archivo no existe, dependencias no instaladas), el sistema continúa funcionando con reglas basadas en conocimiento, registrando advertencias en logs pero sin interrumpir el funcionamiento.

**Modelos implementados:**
- `modelo_respuesta_glucemica.pkl`: XGBoost Regressor para predecir pico glucémico postprandial
- `modelo_seleccion_alimentos.pkl`: XGBoost Classifier para calcular score de idoneidad de alimentos
- `modelo_optimizacion_combinaciones.pkl`: Ensemble (XGBoost + Random Forest) para evaluar calidad de combinaciones
- `scaler_modelo1.pkl`: Scaler para normalización de features del Modelo 1

## 1.1.4.5. Pruebas funcionales clave

**Exclusión de grupos:** Se implementó colector de checkboxes en el frontend mediante JavaScript que itera sobre elementos con clase `checkbox-grupo` y recopila valores marcados en array `grupos_excluidos`. La propagación al backend se implementa mediante serialización JSON en el body de la petición POST a `/api/recomendacion/generar`. Se verificó que el grupo excluido no aparece en el plan mediante validación en `obtener_ingredientes_recomendados` que filtra ingredientes por grupo antes de la selección. Se implementó límite de máximo 2 grupos excluidos mediante validación en JavaScript.

**Variedad multi día:** El plan evita repeticiones excesivas mediante implementación de sistema de seguimiento de `alimentos_usados` que almacena días donde cada alimento fue utilizado. Se aplican reglas de repetición: máximo 3 veces por semana para alimentos generales, mínimo 2 días entre repeticiones, máximo 2 veces por semana para proteínas, mínimo 3 días entre repeticiones de proteínas, y prohibición de proteínas consecutivas. Se realizaron ajustes en el endpoint para usar perfil real del paciente mediante llamada a `obtener_perfil_paciente` que carga datos actualizados desde la base de datos antes de generar el plan.

**Ajuste calórico:** La función `_ajustar_cantidades_por_calorias` corrige cantidades cuando el set de alimentos se reduce por exclusiones mediante cálculo de factor de ajuste que divide calorías objetivo entre calorías actuales, limitado entre 0.5 y 2.0 para evitar cantidades extremas. El factor se aplica proporcionalmente a todas las cantidades de ingredientes, manteniendo proporciones relativas.

**Límites de cantidad por grupo:** Se implementaron límites máximos de cantidad por alimento individual: 200g para cereales, 300g para verduras, 150g para frutas, 250g para lácteos, 250g para carnes, 50g para grasas. Si se necesita más cantidad, el sistema agrega un segundo alimento del mismo grupo (excepto para carnes, donde solo aumenta la cantidad del primer alimento). Para GRUPO1_CEREALES, se implementó lógica de combinaciones válidas que permite combinar diferentes subcategorías (cereal + legumbre, cereal + tubérculo) pero evita duplicados del mismo alimento o legumbres muy similares.

**Paginación multi semana:** Se corrigieron índices en JavaScript mediante cálculo correcto de página actual y total de páginas basado en número de días del plan dividido por 7. La navegación Anterior y Siguiente se implementa mediante funciones JavaScript que actualizan índice de semana actual y recalculan rango de días a mostrar. Se muestra indicador de página actual y total (ej: Semana 1 de 4).

**Persistencia de planes:** Guardado en JSON mediante endpoint `/api/planes` que recibe estructura completa del plan en campo `plan` del body. Se implementan estados Borrador y Publicado mediante campo `estado` que se almacena en tabla `plan`. La vista de detalle se implementa mediante endpoint `/planes/<plan_id>` que carga plan desde base de datos y renderiza template `plan_detalle.html`. Se guarda configuración original (propuesta por el sistema) y configuración ajustada para trazabilidad.

**Sistema de aprendizaje continuo:** Se implementó integración mediante hooks (`hook_plan_guardado`, `hook_plan_completado`) que se ejecutan automáticamente cuando se guarda o completa un plan. El sistema registra baseline (datos iniciales del paciente) cuando se guarda un plan, y actualiza resultados cuando se completa. Esto requiere variable de entorno `APRENDIZAJE_CONTINUO=true` y tablas de aprendizaje continuo creadas en la base de datos (`plan_resultado`, `aprendizaje_patron`, `modelo_reentrenamiento`, `refuerzo_q_values`).

## 1.1.4.6. Evidencia (capturas/flujo)

**Generación con y sin exclusión de grupos:** Se documentó flujo completo de generación de plan con exclusión de GRUPO6_AZUCARES mediante captura de pantalla de interfaz de configuración mostrando checkbox marcado. Se verificó que ningún alimento del grupo excluido aparece en el plan generado mediante inspección de estructura JSON retornada por API. Se documentó flujo de generación sin exclusiones mediante captura de pantalla mostrando todos los grupos disponibles.

**Configuración inteligente:** Se documentó flujo de "Recomendación inteligente" mediante captura de pantalla mostrando botón y resultado con configuración base y configuración ajustada por ML. Se documentó clasificación de control glucémico (BUENO, MODERADO, MALO) y ajustes automáticos de IG máximo y repeticiones máximas.

**Verificación de calorías por comida:** Se documentó cálculo de calorías por comida mediante captura de pantalla de vista de plan mostrando totales nutricionales por tiempo de comida. Se verificó que calorías por comida están dentro de distribución esperada (desayuno 25%, media mañana 10%, almuerzo 35%, media tarde 10%, cena 20%) mediante comparación de valores mostrados con metas calculadas.

**Vista previa en los tres formatos:** Se documentó formato Lista mediante captura de pantalla mostrando alimentos en formato vertical con información nutricional. Se documentó formato Horario mediante captura de pantalla mostrando tabla con horas y alimentos correspondientes. Se documentó formato Tabla Semanal mediante captura de pantalla mostrando grid con días como columnas y comidas como filas, con paginación funcional.

**Publicación y apertura del detalle del plan:** Se documentó flujo de publicación mediante captura de pantalla de botón Publicar y confirmación de cambio de estado. Se documentó apertura del detalle mediante captura de pantalla de vista `plan_detalle.html` mostrando información completa del plan, alimentos por día y recomendaciones especiales.

**Sistema de aprendizaje continuo:** Se documentó registro de baseline mediante captura de pantalla mostrando estado "Baseline registrado" en la vista de detalle del plan. Se documentó información de baseline (HbA1c inicial, glucosa inicial, peso inicial, IMC inicial) y estado (pendiente de resultados).

## 1.1.4.7. Métricas de aceptación (definidas para evaluación continua)

**Cumplimiento de kcal objetivo por comida y día:** Se define cumplimiento como porcentaje de calorías reales dividido entre calorías objetivo, multiplicado por 100. Se considera aceptable si está dentro de más menos 10% de la meta (90% a 110%). Se implementa cálculo mediante función `calcular_cumplimiento_dia` en `OptimizadorPlan` que suma calorías de todos los alimentos en todas las comidas del día y compara con meta diaria. Para macronutrientes individuales (CHO, PRO, FAT), se considera aceptable si están entre 83% y 100%.

**Variedad semanal:** Se define variedad como porcentaje de combinaciones únicas de alimentos por tiempo de comida dividido entre total de comidas del tiempo, multiplicado por 100. Se considera aceptable si es mayor a 60% (más de la mitad de las comidas son diferentes). Se implementa cálculo mediante función `_calcular_variedad_semanal` que cuenta combinaciones únicas de alimentos por tiempo de comida. Se aplican reglas de repetición para evitar monotonía.

**Respeto de exclusiones y límites de IG:** Se define respeto como ausencia de grupos o alimentos excluidos en el plan generado. Se verifica mediante iteración sobre alimentos generados y comparación de nombre de grupo y nombre de alimento contra listas de exclusiones. Se considera aceptable si 100% de exclusiones son respetadas (cero violaciones). Se implementa verificación mediante función `_validar_exclusiones` que retorna lista de violaciones encontradas.

**Tasa de generación sin errores:** Se define tasa como número de planes generados exitosamente dividido entre número total de intentos de generación, multiplicado por 100. Se considera aceptable si es mayor a 95% (menos de 5% de fallos). Se implementa registro mediante logging de excepciones en endpoint `/api/recomendacion/generar` con contador de éxitos y fallos.

**Precisión de predicciones ML:** Se define precisión como porcentaje de predicciones ML que resultan en mejoras clínicas reales. Se considera aceptable si es mayor a 70%. Se implementa seguimiento mediante sistema de aprendizaje continuo que registra resultados reales y los compara con predicciones iniciales.

## 1.1.4.8. Integración del optimizador de planes

El sistema implementa un módulo `OptimizadorPlan` que ajusta iterativamente los planes generados para cumplir objetivos nutricionales con mayor precisión.

**Funcionalidad del optimizador:** El optimizador recibe un plan semanal generado, metas nutricionales, grupos de alimentos disponibles, perfil del paciente y motor de recomendación. Calcula cumplimiento inicial de cada día mediante función `calcular_cumplimiento_dia` que suma valores nutricionales de todos los alimentos y compara con metas. Itera hasta máximo de 20 iteraciones o hasta que todos los días cumplan objetivos (promedio mayor o igual a 90% y todos los macronutrientes entre 83% y 100%).

**Algoritmo de optimización:** Para cada día que no cumple objetivos, identifica déficits de macronutrientes mediante cálculo de diferencia entre porcentaje actual y 90% objetivo. Prioriza ajustes según orden: primero grasas (GRUPO7_GRASAS), luego proteínas (GRUPO5_CARNES), luego carbohidratos (GRUPO1_CEREALES), finalmente calorías totales. Para cada macronutriente con déficit, ajusta comidas principales (almuerzo y cena) primero, luego comidas secundarias si el déficit es grande. Utiliza función `_ajustar_comida_para_macronutriente` que agrega o modifica alimentos en una comida específica para cubrir déficit.

**Integración del Modelo 3:** Durante la optimización, se utiliza el Modelo 3 (Optimización de Combinaciones) mediante función `evaluar_combinacion_alimentos` para validar la calidad de combinaciones sugeridas. Si una combinación tiene score menor a 0.6, se busca una alternativa con mejor score. Esto asegura que las combinaciones de alimentos no solo cumplan objetivos nutricionales, sino que también tengan alta calidad en términos de respuesta glucémica esperada.

**Reducción de excesos:** Si algún macronutriente excede 100%, se aplica función `_reducir_excesos_dia` que reduce proporcionalmente cantidades de alimentos que contribuyen al exceso. Calcula factor de reducción que limita el macronutriente excedente a 100%, luego aplica factor a todas las cantidades manteniendo proporciones.

**Validación post-optimización:** Después de optimizar, se valida que ningún día exceda 100% en ningún macronutriente. Si hay excesos, se aplica reducción automática. Se verifica que variedad se mantenga (no se repitan alimentos excesivamente). Se calcula cumplimiento final y se incluye en estadísticas de optimización retornadas al frontend.

## 1.1.4.9. Integración de modelos ML en tiempo de ejecución

El sistema carga modelos ML bajo demanda cuando se necesita realizar predicciones, optimizando uso de memoria.

**Carga de modelos:** Los modelos se cargan mediante funciones `_cargar_modelo_respuesta_glucemica`, `_cargar_modelo_seleccion_alimentos` y `_cargar_modelo_optimizacion_combinaciones` que verifican si el modelo ya está cargado antes de intentar cargarlo nuevamente. Utilizan rutas relativas desde la raíz del proyecto (`ApartadoInteligente/ModeloML/`) para garantizar portabilidad. Si un modelo no está disponible, el sistema continúa funcionando con reglas basadas en conocimiento, registrando advertencias en logs.

**Predicción de control glucémico:** El modelo de respuesta glucémica se utiliza para predecir probabilidad de mal control mediante función `predecir_control_glucemico_ml` que prepara features del perfil del paciente (edad, sexo, IMC, HbA1c, glucosa, etc.) y realiza predicción. La probabilidad se combina con reglas clínicas mediante función `_determinar_control_glucemico` que ajusta probabilidad si hay valores clínicos elevados (HbA1c mayor o igual a 7.0 aumenta probabilidad a mínimo 0.7). El resultado se utiliza para ajustar metas nutricionales y distribución calórica.

**Selección inteligente de alimentos:** El modelo de selección de alimentos se utiliza para calcular score de idoneidad mediante función `calcular_score_idoneidad_alimento` que prepara features del paciente y del alimento y realiza predicción. Los alimentos se ordenan por score descendente antes de la selección, priorizando aquellos con mayor idoneidad para el perfil del paciente. El score se combina con filtros de seguridad (IG, alergias) para generar lista final de recomendaciones.

**Optimización de combinaciones:** El modelo de optimización de combinaciones se utiliza para evaluar calidad de combinaciones de alimentos mediante función `calcular_score_combinacion` que prepara features de la combinación completa y realiza predicción. Se utiliza durante la optimización para validar que combinaciones sugeridas tengan score mayor a umbral mínimo (0.6 por defecto). Si una combinación tiene score bajo, se busca alternativa con mejor score.

**Flujo de uso de modelos en generación de planes:**

1. **Fase de configuración:** Se utiliza modelo de control glucémico para ajustar configuración base
2. **Fase de selección de ingredientes:** Se utiliza modelo de selección personalizada para rankear alimentos
3. **Fase de generación día por día:** Se utiliza modelo de respuesta glucémica para excluir alimentos con pico excesivo
4. **Fase de optimización:** Se utiliza modelo de optimización de combinaciones para validar calidad de combinaciones

## 1.1.4.10. Endpoint de configuración inteligente

Se implementó endpoint `/api/recomendacion/configuracion/<paciente_id>` que proporciona configuración recomendada con ajuste ML.

**Funcionalidad:** El endpoint obtiene perfil del paciente mediante `obtener_perfil_paciente`. Calcula configuración base (calorías y macronutrientes) mediante fórmulas clínicas estándar (Harris-Benedict para TMB, factores de actividad, ajustes por IMC y control glucémico). Aplica ajuste ML mediante `calcular_metas_nutricionales` que internamente utiliza modelos ML para ajustar configuración base. Retorna configuración base (antes del ajuste ML) y configuración final (después del ajuste ML) para permitir comparación en el frontend.

**Ajustes según control glucémico:** Si probabilidad de mal control mayor a 0.6, se reduce IG máximo a 55 y repeticiones máximas a 2. Si probabilidad entre 0.4 y 0.6, se establece IG máximo a 65 y repeticiones máximas a 3. Si probabilidad menor a 0.4, se establece IG máximo a 70 y repeticiones máximas a 3.

**Respuesta del endpoint:** Incluye `configuracion_base` con valores calculados por reglas clínicas. Incluye `configuracion_final` con valores ajustados por ML. Incluye `metas_nutricionales` con valores finales en gramos y porcentajes. Incluye objeto `ml` con `probabilidad_mal_control` (cruda del modelo), `probabilidad_ajustada` (combinada con reglas) y `control_glucemico` (clasificación: BUENO, MODERADO, MALO).

## 1.1.4.11. Mejoras en interfaz de usuario

**Búsqueda de pacientes mejorada:** Se implementó búsqueda desde primer carácter mediante modificación de event listener en input de búsqueda que dispara búsqueda con `query.length >= 1` (anteriormente requería 2 caracteres). Se mejoró ordenamiento de resultados mediante SQL que prioriza coincidencias exactas o que empiezan con la query, luego coincidencias parciales. Se aumentó límite de resultados a 50 para mostrar más opciones. Se corrigió manejo de respuesta del backend para incluir todos los campos necesarios (dni, nombres, apellidos, sexo, fecha_nac, telefono, email).

**Visualización de cumplimiento:** Se implementó cálculo de cumplimiento en frontend mediante función JavaScript `cumpleObjetivos` que verifica que todos los macronutrientes (Kcal, CHO, PRO, FAT) estén entre 83% y 100%. Se removió texto "Cumple" y "No cumple" de la interfaz, manteniendo solo porcentajes y colores (verde para cumplimiento, amarillo para advertencia, rojo para no cumplimiento). Se corrigió cálculo removiendo `Math.floor()` que causaba redondeo incorrecto, utilizando comparación directa con `Number()`.

**Formato de visualización de planes:** Se implementaron tres formatos de visualización mediante JavaScript que transforma estructura de datos del plan en diferentes representaciones HTML. Formato Lista muestra alimentos en lista vertical con información nutricional expandible. Formato Horario muestra tabla con horas y alimentos correspondientes, útil para seguimiento temporal. Formato Tabla Semanal muestra grid con días como columnas y comidas como filas, útil para visión general de la semana.

**Paginación de semanas:** Se implementó paginación para planes de múltiples semanas mediante JavaScript que divide días del plan en grupos de 7 (semanas). Se calcula número total de páginas mediante `Math.ceil(dias / 7)`. Se implementan botones Anterior y Siguiente que actualizan índice de semana actual y recalculan rango de días a mostrar. Se muestra indicador de página actual y total (ej: Semana 1 de 4).

**Configuración de rango de fechas:** Se implementó select para duración del plan (1, 2 o 3 semanas) en lugar de input de fecha fin. Se limitó fecha de inicio a hoy y hasta una semana desde hoy mediante atributos `min` y `max` en el input. Se calcula automáticamente fecha fin y días del plan basándose en la duración seleccionada.

**Patrón de comidas fijo:** Se implementó que desayuno, almuerzo y cena siempre estén marcados y deshabilitados (no se pueden desmarcar). Media mañana y media tarde son opcionales y editables. Esto asegura que todos los planes incluyan las tres comidas principales.

**Límite de exclusión de grupos:** Se implementó validación en JavaScript que limita la selección de grupos excluidos a máximo 2 grupos. Si el usuario intenta seleccionar más de 2, se muestra alerta y se desmarca el checkbox.

## 1.1.4.12. Sistema de aprendizaje continuo

Se implementó sistema de aprendizaje continuo que permite al sistema mejorar con el tiempo basándose en resultados reales de los planes generados.

**Arquitectura del sistema de aprendizaje:** El sistema utiliza hooks de integración (`hook_plan_guardado`, `hook_plan_completado`) que se ejecutan automáticamente cuando se guarda o completa un plan. Estos hooks están implementados en `aprendizaje/integracion_aprendizaje.py` y se llaman desde `main.py` en los endpoints correspondientes.

**Registro de baseline:** Cuando se guarda un plan, `hook_plan_guardado` se ejecuta automáticamente si `APRENDIZAJE_CONTINUO=true`. Este hook:
- Obtiene datos clínicos actuales del paciente (HbA1c, glucosa en ayunas)
- Obtiene datos antropométricos actuales (peso, talla)
- Calcula IMC
- Registra baseline en la tabla `plan_resultado` con estado 'pendiente'
- Esto permite seguimiento futuro del plan y comparación con resultados finales

**Actualización de resultados:** Cuando un plan se completa (fecha fin alcanzada), `hook_plan_completado` se ejecuta automáticamente. Este hook:
- Obtiene datos clínicos finales del paciente
- Obtiene datos antropométricos finales
- Actualiza el registro en `plan_resultado` con resultados finales
- Calcula mejoras (diferencia entre valores iniciales y finales)
- Marca el estado como 'completado'

**Tablas de aprendizaje continuo:** Se crearon cuatro tablas en la base de datos:
- `plan_resultado`: Almacena baselines y resultados de planes
- `aprendizaje_patron`: Almacena patrones aprendidos (qué funcionó y qué no)
- `modelo_reentrenamiento`: Registra cuándo y cómo se reentrenó el modelo
- `refuerzo_q_values`: Almacena valores Q para aprendizaje por refuerzo

**Habilitación del sistema:** El sistema de aprendizaje continuo se habilita mediante variable de entorno `APRENDIZAJE_CONTINUO=true`. Si no está habilitado, los hooks simplemente retornan sin hacer nada, no afectando el funcionamiento normal del sistema.

**Visualización en interfaz:** En la vista de detalle del plan (`plan_detalle.html`), se muestra el estado del baseline y aprendizaje si está habilitado. Se muestra información como: "Baseline registrado", "Estado: Pendiente de resultados", y valores iniciales (HbA1c, glucosa, peso, IMC).
