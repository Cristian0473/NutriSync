# 1.1.1. Iteración 1: Comprensión de Negocio (CRISP-DM) + Sprint 1 (SCRUM)

## 1.1.1.1. Propósito y alcance del sprint

El objetivo de este primer sprint fue alinear el alcance del proyecto con las necesidades del Hospital Belén de Lambayeque (HBL) para el caso de pacientes con diabetes tipo 2, definiendo objetivos de negocio, actores, datos clínicos mínimos y un backlog inicial de funcionalidades esenciales que habiliten los siguientes sprints (datos, modelado y validación). Se priorizó construir el flujo de pre-registro, activación de cuenta, autenticación, captura clínica y antropométrica como base operativa.

Se definió un alcance inicial centrado en la captura estructurada de datos clínicos y antropométricos pertinentes para futuras recomendaciones, el registro y activación de pacientes, y la gestión básica de planes de alimentación, todo operando en una plataforma web (backend Flask) que soporta autenticación y perfiles de usuario. El foco clínico se acotó a pacientes adultos ambulatorios con DM2.

## 1.1.1.2. Contexto clínico y actores

Los actores considerados fueron: Administrador (gestión de usuarios, roles y configuración), Nutricionista (registro clínico, antropometría y planes) y Paciente (activación de cuenta y futura consulta de recomendaciones).

El sistema implementa un modelo de roles basado en la tabla usuario_rol que permite asignar múltiples roles a un mismo usuario. Los roles definidos son: administrador, nutricionista y paciente. La verificación de roles se realiza mediante decoradores Python que interceptan las solicitudes HTTP antes de ejecutar las funciones de vista.

## 1.1.1.3. Planificación inicial del sprint

Se definió una arquitectura inicial basada en un enfoque cliente-servidor. El back-end se desarrolló utilizando Python con el framework Flask, lo que permite construir servicios ligeros y escalables. La aplicación principal se encuentra en el archivo main.py, que contiene todas las rutas y lógica de negocio del sistema.

El front-end se diseñó con plantillas HTML apoyadas en Bootstrap, asegurando interfaces sencillas para la interacción inicial. Las plantillas utilizan el sistema de herencia de Jinja2, con una plantilla base (base.html) que define la estructura común y plantillas hijas que extienden esta base para cada módulo específico.

Como sistema gestor de base de datos se eligió PostgreSQL en su versión 14, por su robustez y soporte, lo que facilita almacenar configuraciones y preferencias. La conexión a la base de datos se gestiona mediante un módulo centralizado (Core/bd_conexion.py) que implementa un pool de conexiones y proporciona funciones helper: fetch_one, fetch_all y execute, que encapsulan la ejecución de consultas SQL parametrizadas para prevenir inyección SQL.

En la base de datos se implementó el esquema inicial con las tablas más relevantes: usuario, rol y usuario_rol para la gestión de autenticación y perfiles; paciente para los datos básicos; clinico y antropometria para los registros periódicos de salud; ingrediente como catálogo nutricional; y la estructura plan, plan_detalle y plan_alimento para la definición de planes alimenticios personalizados. También se incorporó la tabla perfil_nutricionista para registrar información adicional de los profesionales de la salud.

La tabla pre_registro permite capturar información inicial de pacientes antes de que se active su cuenta en el sistema. La tabla activacion_token almacena tokens temporales con vencimiento para el proceso de activación de cuentas de pacientes.

## 1.1.1.4. Backlog inicial del sprint

Funcionalidad 1: Pre-registro por DNI. El sistema registra o actualiza pre_registro con DNI único y contacto. La implementación se encuentra en la ruta /admin/pre-registro mediante método POST. La función valida que el DNI tenga 8 dígitos y realiza un UPSERT (INSERT ON CONFLICT UPDATE) para evitar duplicados, manteniendo trazabilidad de modificaciones.

Funcionalidad 2: Generar token de activación. Se genera token con vencimiento y estado. La ruta /admin/pre-registro/<dni>/token crea un registro en activacion_token con un UUID único, fecha de expiración calculada según TOKEN_HORAS_VALIDEZ (48 horas por defecto) y estado pendiente. El token se envía por email mediante la función enviar_token_activacion del módulo utils/envio_email.py.

Funcionalidad 3: Activar cuenta. Con DNI y token vigente, se crea o activa un usuario, se vincula a paciente y se marca el token como usado. La ruta /activar procesa la validación del token, verifica que no haya expirado y que no haya sido usado previamente. Si es válido, crea el registro en usuario con contraseña hasheada mediante werkzeug.security.generate_password_hash, asigna el rol paciente automáticamente mediante ensure_role, y marca el token como usado.

Funcionalidad 4: Autenticación. Usuario activo puede iniciar sesión; hash de contraseña obligatorio. La ruta /login acepta DNI o email como identificador. El sistema busca el usuario en la tabla usuario, y si el identificador es DNI, realiza un JOIN con paciente para obtener el usuario_id correspondiente. La verificación de contraseña utiliza werkzeug.security.check_password_hash para comparar de forma segura. Al autenticarse exitosamente, se crea una sesión Flask con user_id y user_email, y se redirige según el rol del usuario.

Funcionalidad 5: Registro clínico. Nutricionista guarda HbA1c, glucosa, LDL, PA, medicamentos y otros (JSON). La ruta /admin/clinico implementa CRUD completo. Los campos numéricos se validan y convierten mediante funciones helper _num y _num_or_none que manejan valores vacíos y excepciones. Los campos de medicación y otros hallazgos se almacenan como JSON mediante json.dumps después de normalizar listas de texto a arrays mediante _parse_json_list.

Funcionalidad 6: Antropometría. Registro de peso, talla, CC, porcentaje de grasa y nivel de actividad; IMC calculado en vista. La ruta /admin/antropometria implementa CRUD. El IMC se calcula dinámicamente en el frontend mediante JavaScript para validación visual, pero no se persiste en la base de datos para evitar inconsistencias. El campo actividad se normaliza mediante _actividad_norm a valores controlados: baja, moderada o alta.

Funcionalidad 7: Administración. Gestión de usuarios, roles y tokens desde panel. Las rutas /admin/usuarios y /admin/roles permiten crear, editar y eliminar usuarios y roles. La asignación de roles se realiza mediante la tabla usuario_rol que mantiene relaciones many-to-many. La función ensure_role garantiza que un usuario tenga un rol específico, creando el registro en usuario_rol si no existe.

Funcionalidad 8: Ingredientes y planes. Gestión de alimentos y generación de planes alimenticios. La ruta /admin/ingredientes implementa CRUD completo con validación de grupos alimentarios mediante lista blanca. Los tags se almacenan como JSON para permitir búsquedas flexibles. La ruta /admin/generar-plan proporciona la interfaz inicial para configurar y generar planes nutricionales.

## 1.1.1.5. Entregables y evidencia

Módulo Pre-registro: Endpoint principal /admin/pre-registro. Estado: Listo. Observación técnica: Upsert por DNI; trazabilidad mediante timestamps de creación y modificación.

Módulo Activaciones: Endpoint principal /admin/pre-registro/<dni>/token. Estado: Listo. Observación técnica: Vencimiento configurable mediante TOKEN_HORAS_VALIDEZ; enlaces de activación generados dinámicamente mediante build_activation_link que construye URLs absolutas usando url_for de Flask.

Módulo Activar cuenta: Endpoint principal /activar. Estado: Listo. Observación técnica: Validación de token y reglas de contraseña implementadas; verificación de complejidad mínima de contraseña en el frontend y backend.

Módulo Autenticación: Endpoint principal /login. Estado: Listo. Observación técnica: Por DNI o email; roles redirigen a rutas específicas mediante decoradores login_required, admin_required y paciente_required que verifican sesión y roles antes de ejecutar vistas.

Módulo Clínico: Endpoint principal /admin/clinico. Estado: Listo. Observación técnica: Parsers numéricos robustos y almacenamiento JSON para listas; validación de rangos clínicos (HbA1c 0-20, PA sistólica 60-250, PA diastólica 40-150).

Módulo Antropometría: Endpoint principal /admin/antropometria. Estado: Listo. Observación técnica: IMC calculado en UI mediante JavaScript; normalización de actividad mediante función _actividad_norm que mapea variaciones de texto a valores controlados.

Módulo Usuarios y Roles: Endpoints principales /admin/usuarios y /admin/roles. Estado: Listo. Observación técnica: Asignación de roles persistente mediante tabla usuario_rol; función get_user_roles retorna lista de roles para un usuario específico.

Módulo Ingredientes: Endpoint principal /admin/ingredientes. Estado: Listo. Observación técnica: JSON tags mediante _norm_tags que acepta JSON válido o texto separado por comas; validación de duplicados por nombre y grupo.

Módulo Planes: Endpoint principal /admin/planes. Estado: Base. Observación técnica: Estructura para integrar recomendaciones; endpoints /api/planes para persistencia y /planes/<plan_id> para visualización.

## 1.1.1.6. Arquitectura técnica implementada

La aplicación Flask se inicializa en main.py con configuración de template_folder y static_folder para organizar recursos. La clave secreta se obtiene de variables de entorno mediante os.getenv para mayor seguridad. El tiempo de sesión se establece en 5 minutos mediante app.permanent_session_lifetime.

El sistema de autenticación utiliza sesiones de Flask con cookies firmadas. Los decoradores de protección implementan verificación de sesión y roles mediante consultas a la base de datos. La función get_user_roles realiza un JOIN entre usuario_rol y rol para obtener los nombres de roles asignados a un usuario.

La gestión de contraseñas utiliza werkzeug.security que implementa PBKDF2 con SHA-256 para hashing seguro. Las contraseñas nunca se almacenan en texto plano, garantizando seguridad incluso si la base de datos es comprometida.

La estructura de base de datos utiliza claves foráneas para mantener integridad referencial. La tabla paciente tiene relación opcional con usuario mediante usuario_id, permitiendo que existan pacientes sin cuenta activa. La tabla pre_registro actúa como fuente de verdad para datos básicos de pacientes antes de la activación.

Los endpoints de API retornan JSON mediante jsonify de Flask, facilitando integración con frontend JavaScript. Los endpoints de vistas renderizan plantillas HTML mediante render_template, pasando datos desde la base de datos a las plantillas Jinja2.

