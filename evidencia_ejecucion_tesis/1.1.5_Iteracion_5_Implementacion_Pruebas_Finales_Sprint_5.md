# 1.1.5. Iteración 5: Implementación y Pruebas Finales del Sistema (CRISP-DM) + Sprint 5 (SCRUM)

## 1.1.5.1. Propósito y alcance del sprint

El objetivo de este quinto sprint fue completar la implementación del sistema mediante corrección de bugs identificados en iteraciones anteriores, implementación de mejoras en variedad de alimentos y límites de cantidad, corrección de rutas y organización de archivos, optimización de rendimiento, y preparación del sistema para uso en producción mediante pruebas exhaustivas y documentación.

Se definió un alcance centrado en la mejora de la calidad de las recomendaciones mediante implementación de sistema de seguimiento de repeticiones de alimentos, filtrado inteligente por repetición con reglas diferenciadas para proteínas, factor de variedad personalizado por paciente, y perfil alimentario dinámico que ajusta priorización según características clínicas. También se incluyó implementación de límites de cantidad por grupo alimentario y lógica de combinaciones inteligentes para cereales, tubérculos y menestras.

El foco técnico se centró en la corrección de rutas y organización de archivos mediante reorganización de estructura en carpetas lógicas (Core, ml, aprendizaje, utils, data_processing), corrección de imports y rutas relativas, y corrección de lógica de control glucémico. También se implementaron mejoras en búsqueda de pacientes, corrección de cálculo de cumplimiento, optimización de rendimiento mediante carga bajo demanda de modelos ML, y preparación para producción mediante manejo robusto de errores, validación de entrada, logging estructurado y documentación de código.

## 1.1.5.2. Mejoras en variedad de alimentos


Sistema de seguimiento de repeticiones: Se implementó diccionario alimentos_usados que almacena para cada alimento una lista de días donde fue utilizado. El diccionario se inicializa vacío al inicio de la generación del plan y se actualiza después de generar cada día. Permite verificar cuántas veces se ha usado un alimento y en qué días, facilitando aplicación de reglas de repetición.

Filtrado inteligente por repetición: Se implementó función _filtrar_alimentos_por_repeticion que clasifica alimentos en tres categorías: priorizados (no usados o usados hace suficiente tiempo), evitados (usados recientemente o máximo de veces alcanzado), prohibidos (proteínas usadas en días consecutivos). Para alimentos generales, máximo 3 veces por semana y mínimo 2 días entre repeticiones. Para proteínas (GRUPO5_CARNES), máximo 2 veces por semana, mínimo 3 días entre repeticiones, y prohibición estricta de uso en días consecutivos.

Factor de variedad personalizado: Se implementó cálculo de factor_variedad único por paciente mediante combinación de características del paciente (ID, edad, peso, IMC, HbA1c, glucosa) con día de la semana y hash MD5 de timestamp. Esto garantiza que diferentes generaciones de planes para el mismo paciente produzcan diferentes selecciones de alimentos, mientras que el mismo paciente en el mismo día siempre obtiene la misma selección (determinismo para debugging).

Perfil alimentario dinámico: Se implementó función _calcular_perfil_alimentario_paciente que ajusta priorización de alimentos según características clínicas. Para diabetes mal controlada (HbA1c mayor o igual a 7.0), prioriza verduras (factor 1.5) y reduce frutas (factor 0.7). Para triglicéridos altos (mayor o igual a 150), prioriza pescado (factor 1.5) y evita carnes rojas. Para LDL alto (mayor o igual a 130), prioriza pescado (factor mínimo 1.3). Para obesidad (IMC mayor o igual a 30), prioriza verduras (factor mínimo 1.2) y reduce frutas.

## 1.1.5.3. Límites de cantidad y combinaciones inteligentes

Sistema de límites por grupo: Se implementó función _obtener_limites_cantidad_grupo que define límites máximos de cantidad por alimento según grupo: GRUPO1_CEREALES 200 gramos, GRUPO2_VERDURAS 300 gramos, GRUPO3_FRUTAS 150 gramos, GRUPO4_LACTEOS 250 gramos, GRUPO5_CARNES 250 gramos, GRUPO7_GRASAS 50 gramos. Cuando se necesitan más calorías después de alcanzar el límite, el sistema implementa lógica diferenciada según el grupo.

Lógica para carnes: Para GRUPO5_CARNES, solo aumenta la cantidad del mismo tipo de carne hasta el máximo de 250 gramos, nunca combina dos tipos diferentes de carne en una misma comida. Esto evita combinaciones poco realistas como pollo más pescado en una sola comida.

Lógica para cereales, tubérculos y menestras: Para GRUPO1_CEREALES, combina inteligentemente diferentes subcategorías mediante función _es_combinacion_valida_grupo1. Permite cereal más legumbre (ej: arroz más lenteja), cereal más tubérculo (ej: arroz más papa), diferentes cereales (ej: arroz más pasta), diferentes tubérculos (ej: papa más camote). Prohíbe el mismo alimento (ej: lenteja más lenteja) y limita combinaciones de legumbres entre sí si son muy similares (ej: lenteja roja más lenteja verde).

Función de agregado con límite: Se implementó función _agregar_alimento_con_limite que maneja agregado de alimentos respetando límites y reglas de combinación. Calcula gramos necesarios mediante _convertir_porciones_a_gramos. Si excede límite, usa máximo y calcula porciones restantes. Para carnes, si hay porciones restantes, aumenta cantidad del primer alimento hasta máximo de 250 gramos. Para GRUPO1_CEREALES, si hay porciones restantes, busca alimentos combinables mediante _es_combinacion_valida_grupo1 y agrega segundo alimento. Para otros grupos, agrega segundo alimento diferente del primero.

## 1.1.5.4. Corrección de rutas y organización de archivos

Reorganización de estructura: Se movieron archivos a carpetas lógicas: Core para código principal del sistema (motor_recomendacion.py, optimizador_plan.py, bd_conexion.py, user.py), ml para scripts de machine learning (entrenar_modelo*.py, preparar_datos_modelo*.py), aprendizaje para módulos de aprendizaje continuo (aprendizaje_continuo.py, integracion_aprendizaje.py), utils para utilidades (envio_email.py, capturar_logs.py), data_processing para procesamiento de datos (explorar_datasets.py, procesar_mfp.py).

Corrección de imports: Se actualizaron todos los imports en archivos Python para reflejar nueva estructura de carpetas. Se cambió from motor_recomendacion import a from Core.motor_recomendacion import. Se crearon archivos __init__.py en cada carpeta para que Python las reconozca como paquetes.

Corrección de rutas de modelos ML: Se corrigieron rutas relativas para carga de modelos ML en motor_recomendacion.py. Se cambió Path(__file__).parent a Path(__file__).parent.parent para apuntar correctamente a la raíz del proyecto desde Core/. Se actualizaron rutas a ApartadoInteligente/ModeloML/ para modelos pickle.

Corrección de rutas de archivos de configuración: Se corrigieron rutas para archivo .env en diagnostico_aprendizaje.py. Se corrigieron rutas para logs_sistema.md en capturar_logs_flask.py. Se corrigieron rutas para scripts ML en pipeline_completo_ml.py.

## 1.1.5.5. Corrección de lógica de control glucémico

Función de determinación mejorada: Se implementó función _determinar_control_glucemico en main.py que maneja correctamente valores None en probabilidades ML. Si probabilidad_ajustada está disponible, la utiliza. Si no, utiliza probabilidad_ml. Si ninguna está disponible, utiliza valores clínicos como fallback: HbA1c mayor o igual a 7.0 o glucosa mayor o igual a 140 indica MALO, HbA1c mayor o igual a 6.5 o glucosa mayor o igual a 126 indica MODERADO, en caso contrario BUENO.

Corrección de clasificación: Se corrigió lógica que evaluaba (probabilidad_ajustada or probabilidad_ml or 0) que podía retornar 0 si ambas probabilidades eran None, causando clasificación incorrecta como BUENO. La nueva función verifica explícitamente si las probabilidades son None antes de usarlas, y solo utiliza fallback clínico cuando ML no está disponible.

Integración en endpoint de configuración: Se integró función _determinar_control_glucemico en endpoint /api/recomendacion/configuracion/<paciente_id> para incluir clasificación de control glucémico en la respuesta. El campo control_glucemico se incluye en objeto ml de la respuesta, permitiendo al frontend mostrar clasificación (BUENO, MODERADO, MALO) al usuario.

## 1.1.5.6. Mejoras en búsqueda de pacientes

Búsqueda desde primer carácter: Se modificó event listener en input de búsqueda para disparar búsqueda con query.length mayor o igual a 1 (anteriormente requería 2 caracteres). Esto mejora experiencia de usuario permitiendo búsqueda inmediata al empezar a escribir.

Mejora en ordenamiento: Se mejoró SQL query en endpoint /api/pacientes/buscar para priorizar coincidencias exactas o que empiezan con la query. Se utiliza CASE WHEN en ORDER BY para ordenar primero por coincidencias exactas de DNI, luego por nombres que empiezan con la query, luego por apellidos que empiezan con la query, finalmente por coincidencias parciales.

Aumento de límite: Se aumentó límite de resultados de 20 a 50 para mostrar más opciones al usuario, especialmente útil cuando hay muchos pacientes con nombres similares.

Inclusión de más datos: Se incluyeron campos adicionales en respuesta: sexo, fecha_nac, telefono, usuario_email. Esto permite al frontend mostrar más información en resultados de búsqueda sin necesidad de consultas adicionales.

Campo ok en respuesta: Se agregó campo ok: True en respuesta JSON para compatibilidad con Select2 y otros componentes frontend que esperan este campo.

## 1.1.5.7. Corrección de cálculo de cumplimiento

Alineación frontend-backend: Se alineó lógica de cálculo de cumplimiento en frontend con lógica del backend. El backend considera cumplimiento si todos los macronutrientes (Kcal, CHO, PRO, FAT) están entre 83% y 100%. El frontend ahora utiliza misma lógica mediante función cumpleObjetivos que verifica cada macronutriente individualmente.

Remoción de Math.floor: Se removió Math.floor del cálculo de cumplimiento en frontend que causaba redondeo incorrecto. Si un porcentaje era 82.9%, Math.floor lo convertía a 82%, causando evaluación incorrecta como No cumple incluso si visualmente se mostraba 83%. Se utiliza comparación directa con Number() para evitar problemas de redondeo.

Actualización de umbral: Se actualizó umbral de cumplimiento de 90% a 83% en frontend para alinearse con criterio del backend. El backend utiliza 83% como mínimo aceptable, permitiendo flexibilidad clínica mientras mantiene calidad nutricional.

Remoción de texto Cumple/No cumple: Se removió texto Cumple y No cumple de la interfaz según solicitud del usuario, manteniendo solo porcentajes y colores (verde para cumplimiento, amarillo para advertencia, rojo para no cumplimiento). Esto reduce confusión visual y enfoca atención en valores numéricos.

## 1.1.5.8. Optimización de rendimiento

Carga bajo demanda de modelos ML: Los modelos ML se cargan solo cuando se necesitan, no al inicializar el motor. Esto reduce tiempo de inicio de la aplicación y uso de memoria cuando no se están generando planes. Se implementa mediante flags _modelo_respuesta_glucemica, _modelo_seleccion_alimentos, _modelo_optimizacion_combinaciones que se inicializan en None y se cargan en primera llamada a funciones de predicción.

Cache de modelos: Una vez cargados, los modelos se mantienen en memoria para reutilización en múltiples generaciones de planes. Esto evita recarga innecesaria de archivos pickle que pueden ser grandes (varios megabytes).

Optimización de consultas SQL: Se optimizaron consultas SQL mediante uso de índices en columnas frecuentemente consultadas (dni, paciente_id, fecha). Se utilizan JOINs eficientes en lugar de subconsultas múltiples. Se limita número de resultados cuando no se necesitan todos (ej: LIMIT 50 en búsqueda de pacientes).

Debounce en búsqueda: Se implementó debounce de 300ms en búsqueda de pacientes para reducir número de peticiones al servidor mientras el usuario escribe. Se utiliza setTimeout y clearTimeout para cancelar peticiones anteriores cuando el usuario continúa escribiendo.

## 1.1.5.9. Preparación para producción

Manejo de errores robusto: Se implementó manejo de errores con try-except en todas las funciones críticas. Los errores se registran en logs con información de contexto (paciente_id, función, parámetros) para facilitar debugging. Se retornan mensajes de error amigables al frontend sin exponer detalles técnicos internos.

Validación de entrada: Se implementó validación de entrada en todos los endpoints que reciben datos del usuario. Se verifica tipo de datos, rangos válidos (ej: IMC entre 10 y 60), formatos correctos (ej: fechas en formato YYYY-MM-DD). Se retornan mensajes de error descriptivos cuando la validación falla.

Logging estructurado: Se implementó logging con prefijos [DEBUG], [OK], [WARN] para facilitar filtrado y análisis. Los logs se escriben a archivo logs_sistema.md mediante módulo capturar_logs_flask.py. Se incluye timestamp, nivel de log, mensaje y contexto relevante.

Documentación de código: Se agregaron docstrings a todas las funciones públicas con descripción de propósito, parámetros, valores de retorno y ejemplos de uso. Se documentaron decisiones de diseño y justificaciones técnicas en comentarios inline.

## 1.1.5.10. Pruebas finales realizadas

Pruebas de generación de planes: Se generaron planes para 10 pacientes diferentes con perfiles variados (diferentes edades, IMC, control glucémico). Se verificó que todos los planes cumplen objetivos nutricionales (83% a 100% en todos los macronutrientes). Se verificó variedad de alimentos (menos de 3 repeticiones por semana para alimentos generales, menos de 2 para proteínas). Se verificó respeto de exclusiones y alergias.

Pruebas de optimizador: Se probó optimizador con planes que inicialmente no cumplían objetivos. Se verificó que el optimizador mejora cumplimiento en iteraciones sucesivas. Se verificó que el optimizador no excede 100% en ningún macronutriente. Se verificó que el optimizador mantiene variedad de alimentos.

Pruebas de modelos ML: Se probó carga de modelos ML desde rutas relativas correctas. Se verificó que predicciones ML se integran correctamente en cálculo de metas. Se verificó que el sistema funciona correctamente cuando modelos ML no están disponibles (fallback a reglas).

Pruebas de interfaz: Se probó búsqueda de pacientes con diferentes queries. Se probó generación de planes con diferentes configuraciones. Se probó visualización de planes en los tres formatos. Se probó paginación de semanas. Se probó guardado y publicación de planes.

Pruebas de integración: Se probó flujo completo desde login hasta generación y guardado de plan. Se probó integración entre frontend y backend mediante peticiones HTTP. Se probó persistencia de datos en base de datos PostgreSQL. Se probó manejo de errores y recuperación ante fallos.

